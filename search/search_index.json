{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyGREAT","text":"<p>A scalable genomic region functional enrichment in Python with the GREAT framework</p> <p> </p>"},{"location":"#what-is-pygreat","title":"What is pyGREAT?","text":"<p>pygreat is a Python package that provides programmatic access to GREAT (Genomic Regions Enrichment of Annotations Tool) from Stanford University. GREAT assigns biological meaning to a set of non-coding genomic regions by analyzing the annotations of nearby genes.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multiple input formats - Submit BED files, URLs, or pandas DataFrames</li> <li>Batch API - Fast results using GREAT's batch processing endpoint</li> <li>Local analysis - Run GREAT offline with custom gene sets (no web service required)</li> <li>Rich results - Get enrichment tables as pandas DataFrames for easy analysis</li> <li>Visualization - Create publication-ready bar and dot plots with seaborn</li> <li>Interactive reports - Generate self-contained HTML reports with filtering, plotting, and export</li> <li>CLI - Beautiful command-line interface powered by rich-click</li> <li>Type hints - Full type annotations for IDE support and static analysis</li> <li>Modern Python - Built for Python 3.10+ with modern syntax</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pygreat import GreatClient\n\n# Submit genomic regions and get enrichment results\nclient = GreatClient()\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Get GO Biological Process enrichment\nresults = job.get_enrichment_tables()\ngo_bp = results[\"GO Biological Process\"]\n\n# Filter significant terms\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\nprint(significant[[\"term_name\", \"binom_fdr\", \"observed_genes\"]].head(10))\n</code></pre>"},{"location":"#command-line","title":"Command Line","text":"<pre><code># Submit to GREAT web service and save results\npygreat submit peaks.bed --species hg38 --output results.tsv\n\n# Or run locally with custom gene sets\npygreat local peaks.bed --gtf genes.gtf --gmt go_terms.gmt -o results.tsv\n\n# Create static visualization\npygreat plot results.tsv -t \"GO Biological Process\" -o enrichment.png\n\n# Generate interactive HTML report\npygreat report results.tsv -o report.html\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pygreat\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use GREAT in your research, please cite:</p> <p>McLean CY, Bristor D, Hiller M, et al. GREAT improves functional interpretation of cis-regulatory regions. Nature Biotechnology. 2010;28(5):495-501.</p>"},{"location":"#license","title":"License","text":"<p>pygreat is released under the MIT License.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to pygreat will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#020-2026-01-30","title":"[0.2.0] - 2026-01-30","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Local GREAT Analysis - Run enrichment analysis locally without requiring the GREAT web service</li> <li><code>LocalGREAT</code> class for offline analysis with custom gene sets</li> <li>Support for GTF gene annotations and GMT gene set files</li> <li>Basal-plus-extension regulatory domain assignment</li> <li>Both binomial and hypergeometric statistical tests</li> <li><code>pygreat local</code> CLI command for local analysis</li> <li>Interactive HTML Reports - Generate self-contained interactive reports from enrichment results</li> <li><code>pygreat report</code> CLI command to create HTML reports</li> <li>Summary panel with total/significant terms per ontology</li> <li>Interactive DataTables with search, sort, and pagination</li> <li>Global filters for FDR, p-value thresholds, and top N terms</li> <li>Term detail modal with stats, gene lists, and GO links (AmiGO, QuickGO)</li> <li>Built-in plot builder for bar and dot plots with Plotly</li> <li>Export options: SVG, PNG, TSV, CSV</li> <li>Single self-contained HTML file (no external dependencies at runtime)</li> <li><code>ReportGenerator</code> and <code>ReportConfig</code> classes for programmatic report generation</li> <li><code>DataProcessor</code> class for loading and validating enrichment results</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Gene name/ID mismatch in local analysis - GMT files using gene symbols now correctly match GTF annotations using gene IDs</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":"<ul> <li>HTML reports use CDN-loaded libraries: Bootstrap 5, DataTables, jQuery, Plotly</li> <li>No new Python dependencies for report generation (uses existing pandas, json)</li> <li>Report module: <code>pygreat.report</code></li> </ul>"},{"location":"changelog/#010-2026-01-24","title":"[0.1.0] - 2026-01-24","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of pygreat</li> <li><code>GreatClient</code> for submitting jobs to GREAT</li> <li>Support for multiple input formats:</li> <li>Local BED files</li> <li>URLs to public BED files (no upload needed)</li> <li>pandas DataFrames</li> <li><code>GenomicRegions</code> objects</li> <li>Batch API integration for fast results</li> <li><code>GreatJob</code> class for accessing enrichment results</li> <li>Filtering by FDR threshold and gene count</li> <li>Export to TSV and DataFrame formats</li> <li>Visualization functions:</li> <li><code>plot_enrichment_bar</code> - horizontal bar plots</li> <li><code>plot_enrichment_dot</code> - dot plots with size and color encoding</li> <li>Command-line interface with rich-click:</li> <li><code>pygreat submit</code> - submit jobs and save results</li> <li><code>pygreat plot</code> - create visualizations</li> <li>Support for GREAT v4.0.4:</li> <li>Species: hg38, hg19, mm10, mm9</li> <li>Association rules: basalPlusExt, twoClosest, oneClosest</li> <li>Background region support for foreground/background analysis</li> <li>Automatic rate limit handling with exponential backoff</li> <li>Full type hints and py.typed marker</li> <li>Comprehensive documentation</li> </ul>"},{"location":"changelog/#technical-details_1","title":"Technical Details","text":"<ul> <li>Uses GREAT batch API (<code>outputType=batch</code>) for direct TSV responses</li> <li>File hosting via transfer.sh for local file uploads</li> <li>HTTP client built on httpx</li> <li>Minimum Python version: 3.10</li> </ul>"},{"location":"changelog/#version-history-format","title":"Version History Format","text":""},{"location":"changelog/#types-of-changes","title":"Types of Changes","text":"<ul> <li>Added - New features</li> <li>Changed - Changes in existing functionality</li> <li>Deprecated - Soon-to-be removed features</li> <li>Removed - Removed features</li> <li>Fixed - Bug fixes</li> <li>Security - Vulnerability fixes</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to pyGREAT! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/khan-lab/pyGREAT.git\ncd pyGREAT\n</code></pre>"},{"location":"contributing/#create-virtual-environment","title":"Create Virtual Environment","text":"<pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre>"},{"location":"contributing/#install-development-dependencies","title":"Install Development Dependencies","text":"<pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This installs pygreat in editable mode with all development dependencies.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>pygreat uses modern Python 3.10+ features and follows these conventions:</p>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>All public functions and methods must have complete type hints:</p> <pre><code>def submit_job(\n    self,\n    regions: str | Path | pd.DataFrame,\n    species: Species = \"hg38\",\n    *,\n    background: str | None = None,\n) -&gt; GreatJob:\n    ...\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def parse(self, content: str) -&gt; dict[str, pd.DataFrame]:\n    \"\"\"Parse batch TSV content.\n\n    Args:\n        content: Raw TSV content from GREAT API.\n\n    Returns:\n        Dictionary mapping ontology names to DataFrames.\n\n    Raises:\n        ParsingError: If content cannot be parsed.\n    \"\"\"\n</code></pre>"},{"location":"contributing/#linting","title":"Linting","text":"<p>Run ruff for linting:</p> <pre><code>ruff check src tests\nruff format src tests\n</code></pre>"},{"location":"contributing/#type-checking","title":"Type Checking","text":"<p>Run mypy for type checking:</p> <pre><code>mypy src\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#run-all-tests","title":"Run All Tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"contributing/#run-unit-tests-only","title":"Run Unit Tests Only","text":"<pre><code>pytest tests/unit/\n</code></pre>"},{"location":"contributing/#run-with-coverage","title":"Run with Coverage","text":"<pre><code>pytest --cov=pygreat --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"contributing/#run-integration-tests","title":"Run Integration Tests","text":"<p>Integration tests hit the real GREAT server and are slow:</p> <pre><code>pytest -m integration\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Place unit tests in <code>tests/unit/</code></li> <li>Place integration tests in <code>tests/integration/</code></li> <li>Use fixtures from <code>tests/conftest.py</code></li> <li>Mock external HTTP calls in unit tests</li> </ul> <p>Example test:</p> <pre><code>import pytest\nfrom pygreat.api.parser import BatchResponseParser\n\n\nclass TestBatchResponseParser:\n    \"\"\"Tests for BatchResponseParser.\"\"\"\n\n    @pytest.fixture\n    def parser(self) -&gt; BatchResponseParser:\n        return BatchResponseParser()\n\n    def test_parse_empty(self, parser: BatchResponseParser) -&gt; None:\n        \"\"\"Test parsing empty content.\"\"\"\n        result = parser.parse(\"\")\n        assert result == {}\n\n    def test_parse_valid(\n        self, parser: BatchResponseParser, mock_batch_response: str\n    ) -&gt; None:\n        \"\"\"Test parsing valid TSV response.\"\"\"\n        results = parser.parse(mock_batch_response)\n        assert \"GO Biological Process\" in results\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#build-documentation-locally","title":"Build Documentation Locally","text":"<pre><code>pip install mkdocs-material mkdocstrings[python]\nmkdocs serve\n</code></pre> <p>Visit <code>http://127.0.0.1:8000</code> to preview.</p>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md              # Home page\n\u251c\u2500\u2500 getting-started/      # Installation and quickstart\n\u251c\u2500\u2500 guide/                # User guides\n\u251c\u2500\u2500 api/                  # API reference\n\u251c\u2500\u2500 examples/             # Code examples\n\u251c\u2500\u2500 contributing.md       # This file\n\u2514\u2500\u2500 changelog.md          # Version history\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#2-make-changes","title":"2. Make Changes","text":"<ul> <li>Write code following the style guide</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul>"},{"location":"contributing/#3-run-checks","title":"3. Run Checks","text":"<pre><code># Lint\nruff check src tests\nruff format --check src tests\n\n# Type check\nmypy src\n\n# Test\npytest\n</code></pre>"},{"location":"contributing/#4-commit","title":"4. Commit","text":"<p>Write clear commit messages:</p> <pre><code>Add support for URL inputs in submit_job\n\n- Skip file upload when input is a URL\n- Add _is_url() helper function\n- Update documentation\n</code></pre>"},{"location":"contributing/#5-push-and-create-pr","title":"5. Push and Create PR","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>pyGREAT/\n\u251c\u2500\u2500 src/pygreat/\n\u2502   \u251c\u2500\u2500 __init__.py        # Package exports\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 client.py      # GreatClient\n\u2502   \u2502   \u251c\u2500\u2500 job.py         # GreatJob\n\u2502   \u2502   \u251c\u2500\u2500 config.py      # Constants\n\u2502   \u2502   \u2514\u2500\u2500 exceptions.py  # Custom exceptions\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 http.py        # HTTP client\n\u2502   \u2502   \u2514\u2500\u2500 parser.py      # Response parsers\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 regions.py     # GenomicRegions\n\u2502   \u2502   \u2514\u2500\u2500 enrichment.py  # EnrichmentResult\n\u2502   \u251c\u2500\u2500 viz/\n\u2502   \u2502   \u251c\u2500\u2500 barplot.py     # Bar plots\n\u2502   \u2502   \u2514\u2500\u2500 dotplot.py     # Dot plots\n\u2502   \u2514\u2500\u2500 cli/\n\u2502       \u2514\u2500\u2500 app.py         # CLI application\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 conftest.py        # Fixtures\n\u2502   \u251c\u2500\u2500 unit/              # Unit tests\n\u2502   \u2514\u2500\u2500 integration/       # Integration tests\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 pyproject.toml         # Package config\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":""},{"location":"contributing/#good-first-issues","title":"Good First Issues","text":"<ul> <li>Add more test coverage</li> <li>Improve error messages</li> <li>Add examples to documentation</li> <li>Fix typos</li> </ul>"},{"location":"contributing/#feature-ideas","title":"Feature Ideas","text":"<ul> <li>Async client support</li> <li>Additional visualization types</li> <li>Support for more file formats</li> <li>Caching mechanisms</li> </ul>"},{"location":"contributing/#documentation_1","title":"Documentation","text":"<ul> <li>Add more examples</li> <li>Improve API documentation</li> <li>Add tutorials</li> <li>Translate documentation</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Feel free to open an issue on GitHub for:</p> <ul> <li>Bug reports</li> <li>Feature requests</li> <li>Questions about the code</li> <li>Help with contributions</li> </ul> <p>Thank you for contributing!</p>"},{"location":"api/client/","title":"GreatClient","text":""},{"location":"api/client/#pygreat.core.client.GreatClient","title":"<code>pygreat.core.client.GreatClient</code>","text":"<p>Client for interacting with the GREAT web service.</p> <p>This client uses the GREAT batch API to submit regions and retrieve enrichment results in a single request.</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <p>The base URL for the GREAT API.</p> <code>version</code> <p>GREAT version to use (default: 4.0.4).</p> <code>request_interval</code> <p>Seconds between retry attempts.</p> <code>max_retries</code> <p>Maximum number of retry attempts.</p> Example <p>from pygreat import GreatClient client = GreatClient() job = client.submit_job(\"peaks.bed\", species=\"hg38\") results = job.get_enrichment_tables() print(results[\"GO Biological Process\"].head())</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.__init__","title":"<code>__init__(base_url=None, version=DEFAULT_VERSION, request_interval=DEFAULT_REQUEST_INTERVAL, max_retries=DEFAULT_MAX_RETRIES, timeout=300.0)</code>","text":"<p>Initialize the GREAT client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str | None</code> <p>Custom base URL for GREAT server.</p> <code>None</code> <code>version</code> <code>str</code> <p>GREAT version (4.0.4, 3.0.0, or 2.0.2).</p> <code>DEFAULT_VERSION</code> <code>request_interval</code> <code>float</code> <p>Seconds between polling attempts.</p> <code>DEFAULT_REQUEST_INTERVAL</code> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts for rate limiting.</p> <code>DEFAULT_MAX_RETRIES</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds.</p> <code>300.0</code>"},{"location":"api/client/#pygreat.core.client.GreatClient.submit_job","title":"<code>submit_job(regions, species='hg38', *, background=None, rule='basalPlusExt', job_name=None, zero_based=False)</code>","text":"<p>Submit a GREAT job for enrichment analysis.</p> <p>This method accepts a URL to a public BED file, or uploads a local BED file to a temporary hosting service, then calls the GREAT batch API and returns results immediately.</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>str | Path | DataFrame | GenomicRegions</code> <p>Input genomic regions as: - URL to a public BED file (http/https) - Local BED file path - pandas DataFrame with genomic regions - GenomicRegions object</p> required <code>species</code> <code>Species</code> <p>Genome assembly (hg38, hg19, mm10, mm9).</p> <code>'hg38'</code> <code>background</code> <code>str | Path | DataFrame | GenomicRegions | None</code> <p>Optional background regions for foreground/background test. Can also be a URL or local file.</p> <code>None</code> <code>rule</code> <code>AssociationRule</code> <p>Gene association rule: - basalPlusExt: Basal regulatory domain with extension (default) - twoClosest: Extends to nearest two genes' TSS - oneClosest: Extends to midpoint of nearest gene's TSS</p> <code>'basalPlusExt'</code> <code>job_name</code> <code>str | None</code> <p>Optional job identifier.</p> <code>None</code> <code>zero_based</code> <code>bool</code> <p>True if input coordinates are 0-based (BED standard). Set to False if coordinates are 1-based.</p> <code>False</code> <p>Returns:</p> Type Description <code>GreatJob</code> <p>GreatJob object with enrichment results.</p> <p>Raises:</p> Type Description <code>InvalidSpeciesError</code> <p>If species is not supported.</p> <code>RateLimitError</code> <p>If rate limit is exceeded after retries.</p> <code>ConnectionError</code> <p>For network/server errors.</p> Example <p>client = GreatClient()</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.submit_job--from-url-no-upload-needed","title":"From URL (no upload needed)","text":"<p>job = client.submit_job(\"https://example.com/peaks.bed\", species=\"hg38\")</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.submit_job--from-local-bed-file","title":"From local BED file","text":"<p>job = client.submit_job(\"peaks.bed\", species=\"hg38\")</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.submit_job--from-dataframe","title":"From DataFrame","text":"<p>df = pd.DataFrame({\"chrom\": [\"chr1\"], \"start\": [1000], \"end\": [2000]}) job = client.submit_job(df, species=\"hg38\")</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.close","title":"<code>close()</code>","text":"<p>Close the HTTP client and release resources.</p>"},{"location":"api/client/#pygreat.core.client.GreatClient.__enter__","title":"<code>__enter__()</code>","text":""},{"location":"api/client/#pygreat.core.client.GreatClient.__exit__","title":"<code>__exit__(*args)</code>","text":""},{"location":"api/client/#overview","title":"Overview","text":"<p><code>GreatClient</code> is the main entry point for interacting with the GREAT web service. It handles:</p> <ul> <li>Uploading genomic regions to a file hosting service (when needed)</li> <li>Calling the GREAT batch API</li> <li>Parsing responses into structured results</li> <li>Managing HTTP connections and rate limiting</li> </ul>"},{"location":"api/client/#basic-usage","title":"Basic Usage","text":"<pre><code>from pygreat import GreatClient\n\n# Create client with default settings\nclient = GreatClient()\n\n# Submit a job\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Get results\nresults = job.get_enrichment_tables()\n\n# Clean up\nclient.close()\n</code></pre>"},{"location":"api/client/#context-manager","title":"Context Manager","text":"<p>Use the context manager pattern for automatic cleanup:</p> <pre><code>with GreatClient() as client:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\n    results = job.get_enrichment_tables()\n# Client is automatically closed\n</code></pre>"},{"location":"api/client/#constructor","title":"Constructor","text":"<pre><code>GreatClient(\n    base_url: str | None = None,\n    version: str = \"4.0.4\",\n    request_interval: float = 30.0,\n    max_retries: int = 5,\n    timeout: float = 300.0,\n)\n</code></pre>"},{"location":"api/client/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>base_url</code> <code>str \\| None</code> <code>None</code> Custom GREAT server URL. If None, uses the official Stanford server. <code>version</code> <code>str</code> <code>\"4.0.4\"</code> GREAT version to use. Affects supported species. <code>request_interval</code> <code>float</code> <code>30.0</code> Base seconds between retry attempts for rate limiting. <code>max_retries</code> <code>int</code> <code>5</code> Maximum number of retry attempts. <code>timeout</code> <code>float</code> <code>300.0</code> HTTP request timeout in seconds."},{"location":"api/client/#methods","title":"Methods","text":""},{"location":"api/client/#submit_job","title":"submit_job","text":"<p>Submit genomic regions to GREAT for enrichment analysis.</p> <pre><code>def submit_job(\n    self,\n    regions: str | Path | pd.DataFrame | GenomicRegions,\n    species: Species = \"hg38\",\n    *,\n    background: str | Path | pd.DataFrame | GenomicRegions | None = None,\n    rule: AssociationRule = \"basalPlusExt\",\n    job_name: str | None = None,\n    zero_based: bool = False,\n) -&gt; GreatJob\n</code></pre>"},{"location":"api/client/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>regions</code> Various Required Input genomic regions. Accepts: BED file path, URL, DataFrame, or GenomicRegions <code>species</code> <code>str</code> <code>\"hg38\"</code> Genome assembly: <code>\"hg38\"</code>, <code>\"hg19\"</code>, <code>\"mm10\"</code>, or <code>\"mm9\"</code> <code>background</code> Various <code>None</code> Optional background regions for foreground/background analysis <code>rule</code> <code>str</code> <code>\"basalPlusExt\"</code> Association rule: <code>\"basalPlusExt\"</code>, <code>\"twoClosest\"</code>, or <code>\"oneClosest\"</code> <code>job_name</code> <code>str \\| None</code> <code>None</code> Optional job identifier <code>zero_based</code> <code>bool</code> <code>False</code> Whether input coordinates are 0-based (BED standard)"},{"location":"api/client/#returns","title":"Returns","text":"<p><code>GreatJob</code> - Object containing enrichment results and metadata.</p>"},{"location":"api/client/#raises","title":"Raises","text":"Exception Condition <code>InvalidSpeciesError</code> Species not supported for the GREAT version <code>RateLimitError</code> Rate limit exceeded after max retries <code>ConnectionError</code> Network or server error"},{"location":"api/client/#examples","title":"Examples","text":"<pre><code># From local file\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# From URL (no upload needed)\njob = client.submit_job(\"https://example.com/peaks.bed\", species=\"hg38\")\n\n# From DataFrame\nimport pandas as pd\ndf = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr2\"],\n    \"start\": [1000, 2000],\n    \"end\": [1500, 2500],\n})\njob = client.submit_job(df, species=\"hg38\")\n\n# With background\njob = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    background=\"background.bed\",\n)\n\n# With custom rule\njob = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    rule=\"twoClosest\",\n)\n</code></pre>"},{"location":"api/client/#close","title":"close","text":"<p>Close the HTTP client and release resources.</p> <pre><code>def close(self) -&gt; None\n</code></pre> <p>Always call <code>close()</code> when done, or use the context manager.</p>"},{"location":"api/client/#attributes","title":"Attributes","text":"Attribute Type Description <code>base_url</code> <code>str</code> The GREAT server URL <code>version</code> <code>str</code> GREAT version <code>request_interval</code> <code>float</code> Base retry interval <code>max_retries</code> <code>int</code> Maximum retries <code>timeout</code> <code>float</code> Request timeout"},{"location":"api/client/#rate-limiting","title":"Rate Limiting","text":"<p>GREAT limits concurrent requests globally (not per-user). pygreat handles rate limiting with exponential backoff:</p> <ol> <li>If rate limited, wait <code>request_interval</code> seconds</li> <li>On subsequent failures, double the wait time (up to 5 minutes)</li> <li>Retry up to <code>max_retries</code> times</li> </ol> <p>Configure for high-load scenarios:</p> <pre><code>client = GreatClient(\n    request_interval=60.0,  # Longer initial wait\n    max_retries=10,         # More attempts\n)\n</code></pre>"},{"location":"api/client/#thread-safety","title":"Thread Safety","text":"<p><code>GreatClient</code> is not thread-safe. For concurrent usage, create separate client instances per thread.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#pygreat.core.exceptions","title":"<code>pygreat.core.exceptions</code>","text":"<p>Custom exceptions for pygreat.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.GreatError","title":"<code>GreatError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for GREAT-related errors.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.InvalidSpeciesError","title":"<code>InvalidSpeciesError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when an unsupported species is specified.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.InvalidRegionsError","title":"<code>InvalidRegionsError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when input regions are invalid.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.RateLimitError","title":"<code>RateLimitError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when GREAT rate limit is exceeded.</p> <p>Attributes:</p> Name Type Description <code>retry_after</code> <p>Suggested wait time in seconds before retrying.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.JobNotFoundError","title":"<code>JobNotFoundError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when a job session is not found on the server.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.ParsingError","title":"<code>ParsingError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when response parsing fails.</p>"},{"location":"api/exceptions/#pygreat.core.exceptions.ConnectionError","title":"<code>ConnectionError</code>","text":"<p>               Bases: <code>GreatError</code></p> <p>Raised when connection to GREAT server fails.</p>"},{"location":"api/exceptions/#overview","title":"Overview","text":"<p>pygreat defines custom exceptions for handling errors that may occur during GREAT analysis.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception\n\u2514\u2500\u2500 GreatError (base class)\n    \u251c\u2500\u2500 InvalidSpeciesError\n    \u251c\u2500\u2500 InvalidInputError\n    \u251c\u2500\u2500 RateLimitError\n    \u251c\u2500\u2500 ParsingError\n    \u2514\u2500\u2500 ConnectionError\n</code></pre>"},{"location":"api/exceptions/#greaterror","title":"GreatError","text":"<p>Base exception for all pygreat errors.</p> <pre><code>from pygreat.core.exceptions import GreatError\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept GreatError as e:\n    print(f\"GREAT error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#invalidspecieserror","title":"InvalidSpeciesError","text":"<p>Raised when an unsupported species/genome assembly is specified.</p> <pre><code>from pygreat.core.exceptions import InvalidSpeciesError\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg100\")  # Invalid\nexcept InvalidSpeciesError as e:\n    print(f\"Invalid species: {e}\")\n    # Invalid species: Species 'hg100' not supported in GREAT v4.0.4.\n    # Supported: ('hg38', 'hg19', 'mm10', 'mm9')\n</code></pre>"},{"location":"api/exceptions/#supported-species","title":"Supported Species","text":"<p>GREAT v4.0.4 supports: - <code>hg38</code> - Human GRCh38 - <code>hg19</code> - Human GRCh37 - <code>mm10</code> - Mouse GRCm38 - <code>mm9</code> - Mouse NCBI37</p>"},{"location":"api/exceptions/#invalidinputerror","title":"InvalidInputError","text":"<p>Raised when input regions are invalid or cannot be parsed.</p> <pre><code>from pygreat.core.exceptions import InvalidInputError\n\ntry:\n    job = client.submit_job(\"invalid.bed\", species=\"hg38\")\nexcept InvalidInputError as e:\n    print(f\"Invalid input: {e}\")\n</code></pre> <p>Common causes: - Malformed BED file - Missing required columns in DataFrame - Empty input - Invalid coordinate values</p>"},{"location":"api/exceptions/#ratelimiterror","title":"RateLimitError","text":"<p>Raised when GREAT's rate limit is exceeded after all retries.</p> <pre><code>from pygreat.core.exceptions import RateLimitError\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept RateLimitError as e:\n    print(f\"Rate limited: {e}\")\n    print(\"Try again later or increase max_retries\")\n</code></pre>"},{"location":"api/exceptions/#handling-rate-limits","title":"Handling Rate Limits","text":"<p>Configure the client for more patient retrying:</p> <pre><code>client = GreatClient(\n    request_interval=60.0,  # Wait 60s between retries\n    max_retries=10,         # Try up to 10 times\n)\n</code></pre>"},{"location":"api/exceptions/#parsingerror","title":"ParsingError","text":"<p>Raised when the GREAT response cannot be parsed.</p> <pre><code>from pygreat.core.exceptions import ParsingError\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept ParsingError as e:\n    print(f\"Failed to parse response: {e}\")\n</code></pre> <p>This usually indicates: - GREAT server returned an error - Unexpected response format - Network issues causing incomplete response</p>"},{"location":"api/exceptions/#connectionerror","title":"ConnectionError","text":"<p>Raised for network or server connectivity issues.</p> <pre><code>from pygreat.core.exceptions import ConnectionError\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept ConnectionError as e:\n    print(f\"Connection failed: {e}\")\n</code></pre> <p>Common causes: - Network unavailable - GREAT server is down - Firewall blocking connection - DNS resolution failed</p>"},{"location":"api/exceptions/#error-handling-best-practices","title":"Error Handling Best Practices","text":""},{"location":"api/exceptions/#catch-specific-exceptions","title":"Catch Specific Exceptions","text":"<pre><code>from pygreat import GreatClient\nfrom pygreat.core.exceptions import (\n    GreatError,\n    InvalidSpeciesError,\n    InvalidInputError,\n    RateLimitError,\n    ParsingError,\n    ConnectionError,\n)\n\ndef run_great_analysis(bed_file, species):\n    client = GreatClient()\n\n    try:\n        job = client.submit_job(bed_file, species=species)\n        return job.get_enrichment_tables()\n\n    except InvalidSpeciesError:\n        print(f\"Species '{species}' is not supported.\")\n        print(\"Use: hg38, hg19, mm10, or mm9\")\n        return None\n\n    except InvalidInputError as e:\n        print(f\"Problem with input file: {e}\")\n        return None\n\n    except RateLimitError:\n        print(\"GREAT is busy. Please try again later.\")\n        return None\n\n    except ParsingError as e:\n        print(f\"Could not parse GREAT response: {e}\")\n        return None\n\n    except ConnectionError:\n        print(\"Could not connect to GREAT server.\")\n        return None\n\n    except GreatError as e:\n        # Catch any other GREAT-related errors\n        print(f\"Unexpected error: {e}\")\n        return None\n\n    finally:\n        client.close()\n</code></pre>"},{"location":"api/exceptions/#retry-logic","title":"Retry Logic","text":"<pre><code>import time\nfrom pygreat.core.exceptions import RateLimitError, ConnectionError\n\ndef submit_with_retry(client, bed_file, species, max_attempts=3):\n    for attempt in range(max_attempts):\n        try:\n            return client.submit_job(bed_file, species=species)\n        except (RateLimitError, ConnectionError) as e:\n            if attempt &lt; max_attempts - 1:\n                wait = 60 * (attempt + 1)\n                print(f\"Attempt {attempt + 1} failed, retrying in {wait}s...\")\n                time.sleep(wait)\n            else:\n                raise\n</code></pre>"},{"location":"api/exceptions/#logging-errors","title":"Logging Errors","text":"<pre><code>import logging\nfrom pygreat.core.exceptions import GreatError\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ntry:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept GreatError as e:\n    logger.error(f\"GREAT analysis failed: {e}\", exc_info=True)\n    raise\n</code></pre>"},{"location":"api/job/","title":"GreatJob","text":""},{"location":"api/job/#pygreat.core.job.GreatJob","title":"<code>pygreat.core.job.GreatJob</code>  <code>dataclass</code>","text":"<p>Represents a completed GREAT job with enrichment results.</p> <p>This class provides methods to access and filter enrichment results that were retrieved from the GREAT batch API.</p> <p>Attributes:</p> Name Type Description <code>job_id</code> <code>str</code> <p>Identifier (typically the hosted file URL).</p> <code>client</code> <code>GreatClient</code> <p>Reference to the GREAT client.</p> <code>ontologies</code> <code>dict[str, list[str]]</code> <p>Available ontology categories.</p> <code>species</code> <code>str</code> <p>Genome assembly used.</p> <code>rule</code> <code>str</code> <p>Association rule used.</p> <code>job_name</code> <code>str | None</code> <p>Optional user-provided name.</p> <code>enrichment_results</code> <code>dict[str, DataFrame]</code> <p>Pre-fetched enrichment DataFrames by ontology.</p> <code>metadata</code> <code>dict[str, str]</code> <p>Batch response metadata (version, species, rule).</p> <code>ontology_stats</code> <code>dict[str, dict[str, Any]]</code> <p>Summary statistics per ontology.</p> Example <p>job = client.submit_job(\"peaks.bed\", species=\"hg38\") results = job.get_enrichment_tables() go_bp = results[\"GO Biological Process\"] print(go_bp[go_bp[\"binom_fdr\"] &lt; 0.05])</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_enrichment_tables","title":"<code>get_enrichment_tables(ontologies=None, *, min_genes=1, max_fdr=1.0)</code>","text":"<p>Retrieve enrichment results for specified ontologies.</p> <p>Parameters:</p> Name Type Description Default <code>ontologies</code> <code>list[str] | None</code> <p>List of ontology names to retrieve. If None, retrieves all available ontologies.</p> <code>None</code> <code>min_genes</code> <code>int</code> <p>Minimum number of observed genes for a term.</p> <code>1</code> <code>max_fdr</code> <code>float</code> <p>Maximum FDR threshold for filtering.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>dict[str, DataFrame]</code> <p>Dictionary mapping ontology names to result DataFrames.</p> <code>dict[str, DataFrame]</code> <p>Each DataFrame contains columns:</p> <code>dict[str, DataFrame]</code> <ul> <li>term_id: Ontology term identifier</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>term_name: Human-readable term name</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>binom_p: Binomial p-value</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>binom_fdr: Binomial FDR</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>binom_fold_enrichment: Binomial fold enrichment</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>hyper_p: Hypergeometric p-value</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>hyper_fdr: Hypergeometric FDR</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>hyper_fold_enrichment: Hypergeometric fold enrichment</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>observed_genes: Number of observed genes</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>total_genes: Total genes in term</li> </ul> <code>dict[str, DataFrame]</code> <ul> <li>observed_regions: Number of observed regions</li> </ul> Example <p>results = job.get_enrichment_tables()</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_enrichment_tables--get-specific-ontologies","title":"Get specific ontologies","text":"<p>results = job.get_enrichment_tables( ...     ontologies=[\"GO Biological Process\", \"GO Molecular Function\"] ... )</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_enrichment_tables--filter-significant-terms","title":"Filter significant terms","text":"<p>results = job.get_enrichment_tables(max_fdr=0.05, min_genes=5)</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_enrichment_table","title":"<code>get_enrichment_table(ontology, *, min_genes=1, max_fdr=1.0)</code>","text":"<p>Retrieve enrichment results for a single ontology.</p> <p>Parameters:</p> Name Type Description Default <code>ontology</code> <code>str</code> <p>Name of the ontology (e.g., 'GO Biological Process').</p> required <code>min_genes</code> <code>int</code> <p>Minimum number of observed genes for a term.</p> <code>1</code> <code>max_fdr</code> <code>float</code> <p>Maximum FDR threshold for filtering.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with enrichment results.</p> Example <p>go_bp = job.get_enrichment_table(\"GO Biological Process\") significant = job.get_enrichment_table( ...     \"GO Biological Process\", max_fdr=0.05 ... )</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.available_ontologies","title":"<code>available_ontologies()</code>","text":"<p>Return available ontology categories and their ontologies.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping category names to lists of ontology names.</p> Example <p>ontologies = job.available_ontologies() for category, names in ontologies.items(): ...     print(f\"{category}: {names}\")</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.list_ontologies","title":"<code>list_ontologies()</code>","text":"<p>Return flat list of all available ontology names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of ontology names.</p> Example <p>ontologies = job.list_ontologies() print(ontologies) ['Ensembl Genes', 'GO Biological Process', ...]</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Return job metadata from GREAT response.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary with version, species, and rule info.</p> Example <p>meta = job.get_metadata() print(f\"GREAT version: {meta['version']}\")</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.get_ontology_stats","title":"<code>get_ontology_stats()</code>","text":"<p>Return ontology summary statistics.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>Dictionary mapping ontology names to stats (terms tested, etc.).</p> Example <p>stats = job.get_ontology_stats() print(stats[\"GO Biological Process\"][\"terms_tested\"])</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.to_dataframe","title":"<code>to_dataframe(ontology=None)</code>","text":"<p>Export results as a single DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>ontology</code> <code>str | None</code> <p>Specific ontology to export. If None, exports all ontologies with an 'ontology' column added.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with enrichment results.</p> Example"},{"location":"api/job/#pygreat.core.job.GreatJob.to_dataframe--export-single-ontology","title":"Export single ontology","text":"<p>df = job.to_dataframe(\"GO Biological Process\")</p>"},{"location":"api/job/#pygreat.core.job.GreatJob.to_dataframe--export-all-ontologies","title":"Export all ontologies","text":"<p>df = job.to_dataframe() df.to_csv(\"results.tsv\", sep=\"\\t\", index=False)</p>"},{"location":"api/job/#overview","title":"Overview","text":"<p><code>GreatJob</code> represents a completed GREAT analysis job. It contains all enrichment results retrieved from the GREAT batch API and provides methods to access, filter, and export these results.</p>"},{"location":"api/job/#attributes","title":"Attributes","text":"Attribute Type Description <code>job_id</code> <code>str</code> Job identifier (typically the hosted file URL) <code>species</code> <code>str</code> Genome assembly used <code>rule</code> <code>str</code> Association rule used <code>job_name</code> <code>str \\| None</code> User-provided job name <code>enrichment_results</code> <code>dict[str, DataFrame]</code> Results by ontology <code>metadata</code> <code>dict[str, str]</code> Job metadata from GREAT <code>ontology_stats</code> <code>dict</code> Summary statistics per ontology"},{"location":"api/job/#methods","title":"Methods","text":""},{"location":"api/job/#get_enrichment_tables","title":"get_enrichment_tables","text":"<p>Retrieve enrichment results for multiple ontologies.</p> <pre><code>def get_enrichment_tables(\n    self,\n    ontologies: list[str] | None = None,\n    *,\n    min_genes: int = 1,\n    max_fdr: float = 1.0,\n) -&gt; dict[str, pd.DataFrame]\n</code></pre>"},{"location":"api/job/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>ontologies</code> <code>list[str] \\| None</code> <code>None</code> Ontologies to retrieve. None = all available <code>min_genes</code> <code>int</code> <code>1</code> Minimum observed genes per term <code>max_fdr</code> <code>float</code> <code>1.0</code> Maximum FDR threshold"},{"location":"api/job/#returns","title":"Returns","text":"<p><code>dict[str, DataFrame]</code> - Dictionary mapping ontology names to result DataFrames.</p>"},{"location":"api/job/#example","title":"Example","text":"<pre><code># All ontologies\nresults = job.get_enrichment_tables()\n\n# Specific ontologies\nresults = job.get_enrichment_tables(\n    ontologies=[\"GO Biological Process\", \"GO Molecular Function\"]\n)\n\n# With filtering\nresults = job.get_enrichment_tables(max_fdr=0.05, min_genes=5)\n</code></pre>"},{"location":"api/job/#get_enrichment_table","title":"get_enrichment_table","text":"<p>Retrieve enrichment results for a single ontology.</p> <pre><code>def get_enrichment_table(\n    self,\n    ontology: str,\n    *,\n    min_genes: int = 1,\n    max_fdr: float = 1.0,\n) -&gt; pd.DataFrame\n</code></pre>"},{"location":"api/job/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>ontology</code> <code>str</code> Required Ontology name <code>min_genes</code> <code>int</code> <code>1</code> Minimum observed genes <code>max_fdr</code> <code>float</code> <code>1.0</code> Maximum FDR threshold"},{"location":"api/job/#returns_1","title":"Returns","text":"<p><code>DataFrame</code> - Enrichment results for the specified ontology.</p>"},{"location":"api/job/#example_1","title":"Example","text":"<pre><code>go_bp = job.get_enrichment_table(\"GO Biological Process\")\nsignificant = job.get_enrichment_table(\"GO Biological Process\", max_fdr=0.05)\n</code></pre>"},{"location":"api/job/#list_ontologies","title":"list_ontologies","text":"<p>Get a flat list of all available ontology names.</p> <pre><code>def list_ontologies(self) -&gt; list[str]\n</code></pre>"},{"location":"api/job/#returns_2","title":"Returns","text":"<p><code>list[str]</code> - List of ontology names.</p>"},{"location":"api/job/#example_2","title":"Example","text":"<pre><code>ontologies = job.list_ontologies()\n# ['GO Biological Process', 'GO Molecular Function', 'GO Cellular Component', ...]\n</code></pre>"},{"location":"api/job/#available_ontologies","title":"available_ontologies","text":"<p>Get ontologies grouped by category.</p> <pre><code>def available_ontologies(self) -&gt; dict[str, list[str]]\n</code></pre>"},{"location":"api/job/#returns_3","title":"Returns","text":"<p><code>dict[str, list[str]]</code> - Dictionary mapping category names to ontology lists.</p>"},{"location":"api/job/#example_3","title":"Example","text":"<pre><code>categories = job.available_ontologies()\n# {'Gene Ontology': ['GO Biological Process', ...], 'Pathway Data': [...]}\n</code></pre>"},{"location":"api/job/#get_metadata","title":"get_metadata","text":"<p>Get job metadata from GREAT response.</p> <pre><code>def get_metadata(self) -&gt; dict[str, str]\n</code></pre>"},{"location":"api/job/#returns_4","title":"Returns","text":"<p><code>dict[str, str]</code> - Dictionary with version, species, and rule information.</p>"},{"location":"api/job/#example_4","title":"Example","text":"<pre><code>meta = job.get_metadata()\nprint(meta)\n# {'version': '4.0.4', 'species': 'hg38', 'rule': 'Basal+extension: ...'}\n</code></pre>"},{"location":"api/job/#get_ontology_stats","title":"get_ontology_stats","text":"<p>Get ontology summary statistics.</p> <pre><code>def get_ontology_stats(self) -&gt; dict[str, dict[str, Any]]\n</code></pre>"},{"location":"api/job/#returns_5","title":"Returns","text":"<p><code>dict[str, dict]</code> - Dictionary mapping ontology names to their statistics.</p>"},{"location":"api/job/#example_5","title":"Example","text":"<pre><code>stats = job.get_ontology_stats()\nprint(stats[\"GO Biological Process\"])\n# {'terms_tested': 13145, 'min_annot_count': '1', 'max_annot_count': 'Inf'}\n</code></pre>"},{"location":"api/job/#to_dataframe","title":"to_dataframe","text":"<p>Export results as a single DataFrame.</p> <pre><code>def to_dataframe(self, ontology: str | None = None) -&gt; pd.DataFrame\n</code></pre>"},{"location":"api/job/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>ontology</code> <code>str \\| None</code> <code>None</code> Specific ontology to export. None = all ontologies"},{"location":"api/job/#returns_6","title":"Returns","text":"<p><code>DataFrame</code> - Enrichment results. When exporting all ontologies, includes an 'ontology' column.</p>"},{"location":"api/job/#example_6","title":"Example","text":"<pre><code># Export all ontologies\ndf = job.to_dataframe()\ndf.to_csv(\"all_results.tsv\", sep=\"\\t\", index=False)\n\n# Export single ontology\ngo_bp = job.to_dataframe(\"GO Biological Process\")\n</code></pre>"},{"location":"api/job/#dataframe-columns","title":"DataFrame Columns","text":"<p>Each enrichment DataFrame contains these columns:</p> Column Type Description <code>term_id</code> str Ontology term ID (e.g., GO:0006915) <code>term_name</code> str Human-readable term name <code>binom_rank</code> int Binomial test rank <code>binom_p</code> float Binomial raw p-value <code>binom_bonferroni</code> float Bonferroni-corrected p-value <code>binom_fdr</code> float FDR-corrected q-value <code>binom_fold_enrichment</code> float Binomial fold enrichment <code>observed_regions</code> int Input regions annotated to term <code>expected_regions</code> float Expected regions under null <code>genome_fraction</code> float Fraction of genome annotated to term <code>region_coverage</code> float Fraction of input regions <code>hyper_rank</code> int Hypergeometric test rank <code>hyper_p</code> float Hypergeometric raw p-value <code>hyper_bonferroni</code> float Hypergeometric Bonferroni <code>hyper_fdr</code> float Hypergeometric FDR <code>hyper_fold_enrichment</code> float Hypergeometric fold enrichment <code>observed_genes</code> int Genes in input regions <code>expected_genes</code> float Expected genes under null <code>total_genes</code> int Total genes annotated to term <code>gene_coverage</code> float Fraction of term genes observed <code>term_coverage</code> float Term coverage <code>regions</code> str Comma-separated region names <code>genes</code> str Comma-separated gene names"},{"location":"api/job/#example-workflow","title":"Example Workflow","text":"<pre><code>from pygreat import GreatClient\n\n# Submit job\nclient = GreatClient()\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Check available ontologies\nprint(job.list_ontologies())\n\n# Get filtered results\nresults = job.get_enrichment_tables(max_fdr=0.05, min_genes=5)\n\n# Access GO Biological Process\ngo_bp = results[\"GO Biological Process\"]\nprint(f\"Found {len(go_bp)} significant terms\")\n\n# Sort by significance\ntop_terms = go_bp.nsmallest(10, \"binom_fdr\")\nprint(top_terms[[\"term_name\", \"binom_fdr\", \"observed_genes\"]])\n\n# Export to file\ndf = job.to_dataframe()\ndf.to_csv(\"results.tsv\", sep=\"\\t\", index=False)\n\n# Clean up\nclient.close()\n</code></pre>"},{"location":"api/regions/","title":"GenomicRegions","text":""},{"location":"api/regions/#pygreat.models.regions.GenomicRegions","title":"<code>pygreat.models.regions.GenomicRegions</code>  <code>dataclass</code>","text":"<p>Collection of genomic regions.</p> <p>Provides conversion to/from various formats and validation.</p> <p>Attributes:</p> Name Type Description <code>regions</code> <code>list[GenomicRegion]</code> <p>List of GenomicRegion objects.</p> Example <p>regions = GenomicRegions.from_bed(\"peaks.bed\") print(f\"Loaded {len(regions)} regions\") bed_bytes = regions.to_bed(gzip_compress=True)</p>"},{"location":"api/regions/#pygreat.models.regions.GenomicRegions.from_bed","title":"<code>from_bed(path, zero_based=True)</code>  <code>classmethod</code>","text":"<p>Load regions from a BED file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to BED file (can be gzipped).</p> required <code>zero_based</code> <code>bool</code> <p>If True, coordinates are 0-based (BED standard). If False, start positions will be converted from 1-based.</p> <code>True</code> <p>Returns:</p> Type Description <code>GenomicRegions</code> <p>GenomicRegions instance.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file does not exist.</p> <code>InvalidRegionsError</code> <p>If regions are invalid.</p>"},{"location":"api/regions/#pygreat.models.regions.GenomicRegions.from_dataframe","title":"<code>from_dataframe(df, zero_based=True, chrom_col=None, start_col=None, end_col=None, name_col=None)</code>  <code>classmethod</code>","text":"<p>Create from pandas DataFrame.</p> <p>Automatically detects common column names if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with chromosome, start, end columns.</p> required <code>zero_based</code> <code>bool</code> <p>If True, coordinates are 0-based.</p> <code>True</code> <code>chrom_col</code> <code>str | None</code> <p>Name of chromosome column (auto-detected if None).</p> <code>None</code> <code>start_col</code> <code>str | None</code> <p>Name of start position column (auto-detected if None).</p> <code>None</code> <code>end_col</code> <code>str | None</code> <p>Name of end position column (auto-detected if None).</p> <code>None</code> <code>name_col</code> <code>str | None</code> <p>Name of region name column (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>GenomicRegions</code> <p>GenomicRegions instance.</p> <p>Raises:</p> Type Description <code>InvalidRegionsError</code> <p>If required columns not found.</p>"},{"location":"api/regions/#pygreat.models.regions.GenomicRegions.to_bed","title":"<code>to_bed(gzip_compress=True)</code>","text":"<p>Convert to BED format bytes.</p> <p>Parameters:</p> Name Type Description Default <code>gzip_compress</code> <code>bool</code> <p>If True, return gzipped content.</p> <code>True</code> <p>Returns:</p> Type Description <code>bytes</code> <p>BED file content as bytes.</p>"},{"location":"api/regions/#pygreat.models.regions.GenomicRegions.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Convert to pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: chrom, start, end, name, score, strand.</p>"},{"location":"api/regions/#pygreat.models.regions.GenomicRegions.validate","title":"<code>validate()</code>","text":"<p>Validate regions.</p> <p>Raises:</p> Type Description <code>InvalidRegionsError</code> <p>If regions are invalid.</p>"},{"location":"api/regions/#overview","title":"Overview","text":"<p><code>GenomicRegions</code> represents a collection of genomic intervals. It handles parsing BED files, DataFrames, and provides methods for exporting regions in various formats.</p>"},{"location":"api/regions/#creating-genomicregions","title":"Creating GenomicRegions","text":""},{"location":"api/regions/#from-bed-file","title":"From BED File","text":"<pre><code>from pygreat.models import GenomicRegions\n\n# From file path\nregions = GenomicRegions.from_bed(\"peaks.bed\")\n\n# With explicit coordinate system\nregions = GenomicRegions.from_bed(\"peaks.bed\", zero_based=True)\n</code></pre>"},{"location":"api/regions/#from-dataframe","title":"From DataFrame","text":"<pre><code>import pandas as pd\nfrom pygreat.models import GenomicRegions\n\ndf = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr1\", \"chr2\"],\n    \"start\": [1000, 5000, 10000],\n    \"end\": [2000, 6000, 11000],\n    \"name\": [\"peak1\", \"peak2\", \"peak3\"],  # Optional\n})\n\nregions = GenomicRegions.from_dataframe(df)\n</code></pre>"},{"location":"api/regions/#from-lists","title":"From Lists","text":"<pre><code>from pygreat.models import GenomicRegions\n\nregions = GenomicRegions(\n    chromosomes=[\"chr1\", \"chr1\", \"chr2\"],\n    starts=[1000, 5000, 10000],\n    ends=[2000, 6000, 11000],\n    names=[\"peak1\", \"peak2\", \"peak3\"],  # Optional\n)\n</code></pre>"},{"location":"api/regions/#class-methods","title":"Class Methods","text":""},{"location":"api/regions/#from_bed","title":"from_bed","text":"<p>Parse a BED file into GenomicRegions.</p> <pre><code>@classmethod\ndef from_bed(\n    cls,\n    path: str | Path,\n    zero_based: bool = True,\n) -&gt; GenomicRegions\n</code></pre>"},{"location":"api/regions/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>path</code> <code>str \\| Path</code> Required Path to BED file <code>zero_based</code> <code>bool</code> <code>True</code> Whether coordinates are 0-based"},{"location":"api/regions/#from_dataframe","title":"from_dataframe","text":"<p>Create GenomicRegions from a pandas DataFrame.</p> <pre><code>@classmethod\ndef from_dataframe(\n    cls,\n    df: pd.DataFrame,\n    zero_based: bool = True,\n) -&gt; GenomicRegions\n</code></pre>"},{"location":"api/regions/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>df</code> <code>DataFrame</code> Required DataFrame with region columns <code>zero_based</code> <code>bool</code> <code>True</code> Whether coordinates are 0-based"},{"location":"api/regions/#recognized-column-names","title":"Recognized Column Names","text":"<p>The DataFrame must have columns for chromosome, start, and end. pygreat recognizes these variations:</p> Field Recognized Names Chromosome <code>chrom</code>, <code>chr</code>, <code>chromosome</code>, <code>seqnames</code>, <code>Chromosome</code> Start <code>start</code>, <code>chromStart</code>, <code>txStart</code>, <code>Start</code> End <code>end</code>, <code>chromEnd</code>, <code>txEnd</code>, <code>End</code> Name <code>name</code>, <code>Name</code>, <code>id</code>, <code>ID</code>"},{"location":"api/regions/#instance-methods","title":"Instance Methods","text":""},{"location":"api/regions/#to_bed","title":"to_bed","text":"<p>Export regions as BED format.</p> <pre><code>def to_bed(self, gzip_compress: bool = False) -&gt; bytes\n</code></pre>"},{"location":"api/regions/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>gzip_compress</code> <code>bool</code> <code>False</code> Whether to gzip compress the output"},{"location":"api/regions/#returns","title":"Returns","text":"<p><code>bytes</code> - BED content as bytes.</p>"},{"location":"api/regions/#example","title":"Example","text":"<pre><code># Plain BED\nbed_content = regions.to_bed()\n\n# Gzipped\nbed_gz = regions.to_bed(gzip_compress=True)\n\n# Save to file\nwith open(\"output.bed\", \"wb\") as f:\n    f.write(regions.to_bed())\n</code></pre>"},{"location":"api/regions/#to_dataframe","title":"to_dataframe","text":"<p>Convert to a pandas DataFrame.</p> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame\n</code></pre>"},{"location":"api/regions/#returns_1","title":"Returns","text":"<p><code>DataFrame</code> - DataFrame with chrom, start, end, and name columns.</p>"},{"location":"api/regions/#example_1","title":"Example","text":"<pre><code>df = regions.to_dataframe()\nprint(df)\n#   chrom  start    end   name\n# 0  chr1   1000   2000  peak1\n# 1  chr1   5000   6000  peak2\n# 2  chr2  10000  11000  peak3\n</code></pre>"},{"location":"api/regions/#properties","title":"Properties","text":"Property Type Description <code>chromosomes</code> <code>list[str]</code> List of chromosome names <code>starts</code> <code>list[int]</code> List of start positions <code>ends</code> <code>list[int]</code> List of end positions <code>names</code> <code>list[str]</code> List of region names"},{"location":"api/regions/#iteration","title":"Iteration","text":"<p>GenomicRegions supports iteration:</p> <pre><code>for chrom, start, end, name in regions:\n    print(f\"{chrom}:{start}-{end} ({name})\")\n</code></pre>"},{"location":"api/regions/#length","title":"Length","text":"<p>Get the number of regions:</p> <pre><code>n_regions = len(regions)\n</code></pre>"},{"location":"api/regions/#example-filtering-regions","title":"Example: Filtering Regions","text":"<pre><code>from pygreat.models import GenomicRegions\n\n# Load regions\nregions = GenomicRegions.from_bed(\"peaks.bed\")\n\n# Convert to DataFrame for filtering\ndf = regions.to_dataframe()\n\n# Filter to specific chromosome\nchr1_df = df[df[\"chrom\"] == \"chr1\"]\n\n# Create new GenomicRegions from filtered DataFrame\nchr1_regions = GenomicRegions.from_dataframe(chr1_df)\n</code></pre>"},{"location":"api/regions/#example-merging-regions","title":"Example: Merging Regions","text":"<pre><code>import pandas as pd\nfrom pygreat.models import GenomicRegions\n\n# Load two region sets\nregions1 = GenomicRegions.from_bed(\"peaks1.bed\")\nregions2 = GenomicRegions.from_bed(\"peaks2.bed\")\n\n# Merge using DataFrames\ndf = pd.concat([\n    regions1.to_dataframe(),\n    regions2.to_dataframe(),\n], ignore_index=True)\n\n# Remove duplicates\ndf = df.drop_duplicates(subset=[\"chrom\", \"start\", \"end\"])\n\n# Create merged GenomicRegions\nmerged = GenomicRegions.from_dataframe(df)\n</code></pre>"},{"location":"api/viz/","title":"Visualization","text":""},{"location":"api/viz/#pygreat.viz","title":"<code>pygreat.viz</code>","text":"<p>Visualization module for enrichment results.</p>"},{"location":"api/viz/#pygreat.viz.plot_enrichment_bar","title":"<code>plot_enrichment_bar(data, *, n_terms=15, value_column='binom_fdr', color_column=None, title='Top Enriched Terms', xlabel=None, figsize=(10, 8), palette='viridis_r', ax=None)</code>","text":"<p>Create a bar plot of top enriched terms.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with enrichment results.</p> required <code>n_terms</code> <code>int</code> <p>Number of top terms to display.</p> <code>15</code> <code>value_column</code> <code>Literal['binom_fdr', 'hyper_fdr', 'binom_fold_enrichment', 'hyper_fold_enrichment']</code> <p>Column to use for bar values. For FDR columns, values are transformed to -log10.</p> <code>'binom_fdr'</code> <code>color_column</code> <code>str | None</code> <p>Column to use for bar colors (optional).</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Top Enriched Terms'</code> <code>xlabel</code> <code>str | None</code> <p>X-axis label (auto-generated if None).</p> <code>None</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size in inches.</p> <code>(10, 8)</code> <code>palette</code> <code>str</code> <p>Seaborn color palette name.</p> <code>'viridis_r'</code> <code>ax</code> <code>Axes | None</code> <p>Existing axes to plot on.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>Tuple of (Figure, Axes).</p> Example <p>from pygreat.viz import plot_enrichment_bar fig, ax = plot_enrichment_bar( ...     results[\"GO Biological Process\"], ...     n_terms=20, ...     value_column=\"binom_fdr\", ... ) plt.savefig(\"enrichment.png\", dpi=300, bbox_inches=\"tight\")</p>"},{"location":"api/viz/#pygreat.viz.plot_multi_ontology_bar","title":"<code>plot_multi_ontology_bar(results, *, ontologies=None, n_terms_per_ontology=5, figsize=(12, 10), palette='Set2', title='Top Enriched Terms by Ontology')</code>","text":"<p>Create a grouped bar plot across multiple ontologies.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict[str, DataFrame]</code> <p>Dictionary mapping ontology names to DataFrames.</p> required <code>ontologies</code> <code>list[str] | None</code> <p>Ontologies to include (None for all).</p> <code>None</code> <code>n_terms_per_ontology</code> <code>int</code> <p>Terms per ontology.</p> <code>5</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size.</p> <code>(12, 10)</code> <code>palette</code> <code>str</code> <p>Color palette name.</p> <code>'Set2'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Top Enriched Terms by Ontology'</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>Tuple of (Figure, Axes).</p> Example <p>fig, ax = plot_multi_ontology_bar( ...     results, ...     ontologies=[\"GO Biological Process\", \"GO Molecular Function\"], ...     n_terms_per_ontology=5, ... )</p>"},{"location":"api/viz/#pygreat.viz.plot_enrichment_dot","title":"<code>plot_enrichment_dot(data, *, n_terms=20, size_column='observed_genes', color_column='binom_fdr', x_column='binom_fold_enrichment', title='Enrichment Dot Plot', figsize=(10, 8), cmap='RdYlBu_r', size_range=(50, 400), ax=None)</code>","text":"<p>Create a dot plot of enrichment results.</p> <p>Dot size represents gene count, color represents significance, and x-position represents fold enrichment.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with enrichment results.</p> required <code>n_terms</code> <code>int</code> <p>Number of terms to display.</p> <code>20</code> <code>size_column</code> <code>str</code> <p>Column for dot size (typically gene count).</p> <code>'observed_genes'</code> <code>color_column</code> <code>str</code> <p>Column for dot color (typically FDR).</p> <code>'binom_fdr'</code> <code>x_column</code> <code>str</code> <p>Column for x-axis values (typically fold enrichment).</p> <code>'binom_fold_enrichment'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Enrichment Dot Plot'</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size in inches.</p> <code>(10, 8)</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap for significance.</p> <code>'RdYlBu_r'</code> <code>size_range</code> <code>tuple[int, int]</code> <p>Min and max dot sizes in points.</p> <code>(50, 400)</code> <code>ax</code> <code>Axes | None</code> <p>Existing axes to plot on.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>Tuple of (Figure, Axes).</p> Example <p>from pygreat.viz import plot_enrichment_dot fig, ax = plot_enrichment_dot( ...     results[\"GO Biological Process\"], ...     n_terms=25, ...     size_column=\"observed_genes\", ...     color_column=\"binom_fdr\", ... ) plt.savefig(\"dotplot.png\", dpi=300, bbox_inches=\"tight\")</p>"},{"location":"api/viz/#overview","title":"Overview","text":"<p>pygreat provides two visualization functions for creating publication-ready enrichment plots:</p> <ul> <li><code>plot_enrichment_bar</code> - Horizontal bar plot of top enriched terms</li> <li><code>plot_enrichment_dot</code> - Dot plot showing significance, gene count, and fold enrichment</li> </ul> <p>Both functions use seaborn and matplotlib and return a figure and axes object for further customization.</p>"},{"location":"api/viz/#plot_enrichment_bar","title":"plot_enrichment_bar","text":"<p>Create a horizontal bar plot showing -log10(FDR) for top enriched terms.</p> <pre><code>from pygreat.viz import plot_enrichment_bar\n</code></pre>"},{"location":"api/viz/#signature","title":"Signature","text":"<pre><code>def plot_enrichment_bar(\n    df: pd.DataFrame,\n    n_terms: int = 15,\n    pvalue_col: str = \"binom_fdr\",\n    name_col: str = \"term_name\",\n    title: str | None = None,\n    xlabel: str = \"-log10(FDR)\",\n    color: str | Sequence = \"steelblue\",\n    figsize: tuple[float, float] = (10, 8),\n    ax: plt.Axes | None = None,\n    max_label_length: int = 50,\n) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre>"},{"location":"api/viz/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>df</code> <code>DataFrame</code> Required Enrichment results DataFrame <code>n_terms</code> <code>int</code> <code>15</code> Number of top terms to show <code>pvalue_col</code> <code>str</code> <code>\"binom_fdr\"</code> Column name for p-values/FDR <code>name_col</code> <code>str</code> <code>\"term_name\"</code> Column name for term names <code>title</code> <code>str \\| None</code> <code>None</code> Plot title <code>xlabel</code> <code>str</code> <code>\"-log10(FDR)\"</code> X-axis label <code>color</code> <code>str \\| Sequence</code> <code>\"steelblue\"</code> Bar color(s) <code>figsize</code> <code>tuple</code> <code>(10, 8)</code> Figure size (width, height) <code>ax</code> <code>Axes \\| None</code> <code>None</code> Existing axes to plot on <code>max_label_length</code> <code>int</code> <code>50</code> Truncate labels longer than this"},{"location":"api/viz/#returns","title":"Returns","text":"<p><code>tuple[Figure, Axes]</code> - Matplotlib figure and axes objects.</p>"},{"location":"api/viz/#examples","title":"Examples","text":"<pre><code>from pygreat.viz import plot_enrichment_bar\n\n# Basic usage\nfig, ax = plot_enrichment_bar(go_bp, n_terms=15)\nfig.savefig(\"barplot.png\", dpi=300, bbox_inches=\"tight\")\n\n# With title\nfig, ax = plot_enrichment_bar(\n    go_bp,\n    n_terms=20,\n    title=\"GO Biological Process Enrichment\",\n)\n\n# Custom color\nfig, ax = plot_enrichment_bar(go_bp, color=\"darkred\")\n\n# Color by fold enrichment\nfig, ax = plot_enrichment_bar(\n    go_bp,\n    color=go_bp[\"binom_fold_enrichment\"],\n)\n</code></pre>"},{"location":"api/viz/#plot_enrichment_dot","title":"plot_enrichment_dot","text":"<p>Create a dot plot showing significance (x-axis), gene count (dot size), and fold enrichment (color).</p> <pre><code>from pygreat.viz import plot_enrichment_dot\n</code></pre>"},{"location":"api/viz/#signature_1","title":"Signature","text":"<pre><code>def plot_enrichment_dot(\n    df: pd.DataFrame,\n    n_terms: int = 15,\n    pvalue_col: str = \"binom_fdr\",\n    size_col: str = \"observed_genes\",\n    color_col: str = \"binom_fold_enrichment\",\n    name_col: str = \"term_name\",\n    title: str | None = None,\n    xlabel: str = \"-log10(FDR)\",\n    figsize: tuple[float, float] = (10, 8),\n    ax: plt.Axes | None = None,\n    cmap: str = \"viridis\",\n    size_range: tuple[float, float] = (50, 500),\n    max_label_length: int = 50,\n) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre>"},{"location":"api/viz/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>df</code> <code>DataFrame</code> Required Enrichment results DataFrame <code>n_terms</code> <code>int</code> <code>15</code> Number of top terms to show <code>pvalue_col</code> <code>str</code> <code>\"binom_fdr\"</code> Column for p-values/FDR <code>size_col</code> <code>str</code> <code>\"observed_genes\"</code> Column for dot sizes <code>color_col</code> <code>str</code> <code>\"binom_fold_enrichment\"</code> Column for dot colors <code>name_col</code> <code>str</code> <code>\"term_name\"</code> Column for term names <code>title</code> <code>str \\| None</code> <code>None</code> Plot title <code>xlabel</code> <code>str</code> <code>\"-log10(FDR)\"</code> X-axis label <code>figsize</code> <code>tuple</code> <code>(10, 8)</code> Figure size <code>ax</code> <code>Axes \\| None</code> <code>None</code> Existing axes to plot on <code>cmap</code> <code>str</code> <code>\"viridis\"</code> Matplotlib colormap name <code>size_range</code> <code>tuple</code> <code>(50, 500)</code> Min and max dot sizes <code>max_label_length</code> <code>int</code> <code>50</code> Truncate labels longer than this"},{"location":"api/viz/#returns_1","title":"Returns","text":"<p><code>tuple[Figure, Axes]</code> - Matplotlib figure and axes objects.</p>"},{"location":"api/viz/#examples_1","title":"Examples","text":"<pre><code>from pygreat.viz import plot_enrichment_dot\n\n# Basic usage\nfig, ax = plot_enrichment_dot(go_bp, n_terms=15)\nfig.savefig(\"dotplot.png\", dpi=300, bbox_inches=\"tight\")\n\n# Custom colormap\nfig, ax = plot_enrichment_dot(\n    go_bp,\n    n_terms=20,\n    cmap=\"YlOrRd\",\n)\n\n# Custom size range\nfig, ax = plot_enrichment_dot(\n    go_bp,\n    size_range=(20, 300),\n)\n</code></pre>"},{"location":"api/viz/#common-patterns","title":"Common Patterns","text":""},{"location":"api/viz/#save-in-multiple-formats","title":"Save in Multiple Formats","text":"<pre><code>fig, ax = plot_enrichment_bar(go_bp)\n\n# Raster formats\nfig.savefig(\"plot.png\", dpi=300, bbox_inches=\"tight\")\nfig.savefig(\"plot.jpg\", dpi=300, bbox_inches=\"tight\")\n\n# Vector formats (for publications)\nfig.savefig(\"plot.pdf\", bbox_inches=\"tight\")\nfig.savefig(\"plot.svg\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/viz/#subplots","title":"Subplots","text":"<pre><code>import matplotlib.pyplot as plt\nfrom pygreat.viz import plot_enrichment_bar\n\nfig, axes = plt.subplots(1, 2, figsize=(16, 6))\n\n# Bar plot\nplot_enrichment_bar(go_bp, ax=axes[0], title=\"GO Biological Process\")\n\n# Another ontology\nplot_enrichment_bar(go_mf, ax=axes[1], title=\"GO Molecular Function\")\n\nplt.tight_layout()\nfig.savefig(\"comparison.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/viz/#publication-style","title":"Publication Style","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Set style\nplt.style.use('seaborn-v0_8-whitegrid')\nplt.rcParams.update({\n    'font.size': 12,\n    'font.family': 'sans-serif',\n    'axes.labelsize': 14,\n    'axes.titlesize': 16,\n})\n\nfig, ax = plot_enrichment_bar(go_bp, n_terms=15)\nfig.savefig(\"publication_figure.pdf\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/viz/#add-significance-line","title":"Add Significance Line","text":"<pre><code>fig, ax = plot_enrichment_bar(go_bp)\n\n# Add line at FDR = 0.05\nax.axvline(-np.log10(0.05), color='red', linestyle='--', label='FDR = 0.05')\nax.legend()\n\nfig.savefig(\"with_threshold.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Usage Examples","text":"<p>This page covers advanced usage patterns for pygreat.</p>"},{"location":"examples/advanced/#example-1-batch-processing-multiple-samples","title":"Example 1: Batch Processing Multiple Samples","text":"<p>Process multiple BED files in sequence.</p> <pre><code>from pathlib import Path\nimport pandas as pd\nfrom pygreat import GreatClient\n\n\ndef process_samples(sample_dir, species=\"hg38\"):\n    \"\"\"Process all BED files in a directory.\"\"\"\n    sample_dir = Path(sample_dir)\n    results = {}\n\n    with GreatClient() as client:\n        for bed_file in sample_dir.glob(\"*.bed\"):\n            sample_name = bed_file.stem\n            print(f\"Processing {sample_name}...\")\n\n            job = client.submit_job(bed_file, species=species)\n            sample_results = job.get_enrichment_tables(max_fdr=0.05)\n\n            results[sample_name] = sample_results\n\n    return results\n\n\n# Process all samples\nall_results = process_samples(\"samples/\", species=\"hg38\")\n\n# Combine GO BP results across samples\ncombined = []\nfor sample, results in all_results.items():\n    go_bp = results.get(\"GO Biological Process\")\n    if go_bp is not None and not go_bp.empty:\n        go_bp = go_bp.copy()\n        go_bp[\"sample\"] = sample\n        combined.append(go_bp)\n\nif combined:\n    combined_df = pd.concat(combined, ignore_index=True)\n    combined_df.to_csv(\"combined_go_bp.tsv\", sep=\"\\t\", index=False)\n</code></pre>"},{"location":"examples/advanced/#example-2-comparison-across-conditions","title":"Example 2: Comparison Across Conditions","text":"<p>Compare enrichment between two conditions.</p> <pre><code>import numpy as np\nimport pandas as pd\nfrom pygreat import GreatClient\n\n\ndef get_top_terms(df, n=20):\n    \"\"\"Get top N terms by significance.\"\"\"\n    return set(df.nsmallest(n, \"binom_fdr\")[\"term_name\"])\n\n\n# Run GREAT for two conditions\nwith GreatClient() as client:\n    job_ctrl = client.submit_job(\"control_peaks.bed\", species=\"hg38\")\n    job_treat = client.submit_job(\"treatment_peaks.bed\", species=\"hg38\")\n\n    ctrl_results = job_ctrl.get_enrichment_tables()\n    treat_results = job_treat.get_enrichment_tables()\n\n# Get GO BP results\nctrl_bp = ctrl_results[\"GO Biological Process\"]\ntreat_bp = treat_results[\"GO Biological Process\"]\n\n# Find top terms from both\ntop_terms = get_top_terms(ctrl_bp, 30) | get_top_terms(treat_bp, 30)\n\n# Create comparison table\ncomparison = []\nfor term in top_terms:\n    ctrl_row = ctrl_bp[ctrl_bp[\"term_name\"] == term]\n    treat_row = treat_bp[treat_bp[\"term_name\"] == term]\n\n    comparison.append({\n        \"term_name\": term,\n        \"control_fdr\": ctrl_row[\"binom_fdr\"].values[0] if len(ctrl_row) else 1.0,\n        \"treatment_fdr\": treat_row[\"binom_fdr\"].values[0] if len(treat_row) else 1.0,\n        \"control_genes\": ctrl_row[\"observed_genes\"].values[0] if len(ctrl_row) else 0,\n        \"treatment_genes\": treat_row[\"observed_genes\"].values[0] if len(treat_row) else 0,\n    })\n\ncomparison_df = pd.DataFrame(comparison)\ncomparison_df[\"log2_fc\"] = np.log2(\n    (comparison_df[\"treatment_genes\"] + 1) / (comparison_df[\"control_genes\"] + 1)\n)\n\n# Sort by difference\ncomparison_df = comparison_df.sort_values(\"log2_fc\", ascending=False)\nprint(comparison_df.head(20))\n</code></pre>"},{"location":"examples/advanced/#example-3-enrichment-heatmap","title":"Example 3: Enrichment Heatmap","text":"<p>Create a heatmap across multiple samples.</p> <pre><code>import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom pygreat import GreatClient\n\n\ndef run_great(client, bed_file, species):\n    \"\"\"Run GREAT and return GO BP results.\"\"\"\n    job = client.submit_job(bed_file, species=species)\n    results = job.get_enrichment_tables()\n    return results.get(\"GO Biological Process\")\n\n\n# Sample files\nsamples = {\n    \"Sample_A\": \"sampleA.bed\",\n    \"Sample_B\": \"sampleB.bed\",\n    \"Sample_C\": \"sampleC.bed\",\n    \"Sample_D\": \"sampleD.bed\",\n}\n\n# Run GREAT for all samples\nwith GreatClient() as client:\n    sample_results = {\n        name: run_great(client, path, \"hg38\")\n        for name, path in samples.items()\n    }\n\n# Collect top terms across all samples\nall_top_terms = set()\nfor name, df in sample_results.items():\n    if df is not None:\n        top = df.nsmallest(15, \"binom_fdr\")[\"term_name\"].tolist()\n        all_top_terms.update(top)\n\ntop_terms = sorted(all_top_terms)[:30]  # Limit to 30\n\n# Build matrix\nmatrix = np.zeros((len(top_terms), len(samples)))\nsample_names = list(samples.keys())\n\nfor j, name in enumerate(sample_names):\n    df = sample_results[name]\n    if df is not None:\n        for i, term in enumerate(top_terms):\n            row = df[df[\"term_name\"] == term]\n            if not row.empty:\n                fdr = row[\"binom_fdr\"].values[0]\n                matrix[i, j] = -np.log10(fdr + 1e-300)\n\n# Create heatmap\nplt.figure(figsize=(10, 12))\nsns.heatmap(\n    matrix,\n    xticklabels=sample_names,\n    yticklabels=top_terms,\n    cmap=\"YlOrRd\",\n    cbar_kws={\"label\": \"-log10(FDR)\"},\n)\nplt.title(\"GO Biological Process Enrichment\")\nplt.tight_layout()\nplt.savefig(\"enrichment_heatmap.png\", dpi=300)\n</code></pre>"},{"location":"examples/advanced/#example-4-custom-genomicregions","title":"Example 4: Custom GenomicRegions","text":"<p>Work with GenomicRegions directly for preprocessing.</p> <pre><code>import pandas as pd\nfrom pygreat import GreatClient\nfrom pygreat.models import GenomicRegions\n\n\n# Load and filter regions\nregions = GenomicRegions.from_bed(\"peaks.bed\")\ndf = regions.to_dataframe()\n\n# Filter to specific chromosomes\nautosomes = [f\"chr{i}\" for i in range(1, 23)]\ndf_filtered = df[df[\"chrom\"].isin(autosomes)]\n\n# Filter by region size\ndf_filtered = df_filtered[\n    (df_filtered[\"end\"] - df_filtered[\"start\"]) &gt;= 100\n]\n\n# Create new GenomicRegions\nfiltered_regions = GenomicRegions.from_dataframe(df_filtered)\n\nprint(f\"Original: {len(regions)} regions\")\nprint(f\"Filtered: {len(filtered_regions)} regions\")\n\n# Submit filtered regions\nwith GreatClient() as client:\n    job = client.submit_job(filtered_regions, species=\"hg38\")\n    results = job.get_enrichment_tables()\n</code></pre>"},{"location":"examples/advanced/#example-5-parallel-processing-with-threadpool","title":"Example 5: Parallel Processing with ThreadPool","text":"<p>Process samples in parallel (create separate clients per thread).</p> <pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom pathlib import Path\nfrom pygreat import GreatClient\n\n\ndef process_sample(bed_file, species=\"hg38\"):\n    \"\"\"Process a single sample with its own client.\"\"\"\n    # Each thread needs its own client\n    with GreatClient() as client:\n        job = client.submit_job(bed_file, species=species)\n        results = job.get_enrichment_tables(max_fdr=0.05)\n\n    return bed_file.stem, results\n\n\ndef process_parallel(sample_dir, max_workers=3):\n    \"\"\"Process samples in parallel.\"\"\"\n    sample_dir = Path(sample_dir)\n    bed_files = list(sample_dir.glob(\"*.bed\"))\n\n    all_results = {}\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(process_sample, bed): bed\n            for bed in bed_files\n        }\n\n        for future in as_completed(futures):\n            bed_file = futures[future]\n            try:\n                sample_name, results = future.result()\n                all_results[sample_name] = results\n                print(f\"Completed: {sample_name}\")\n            except Exception as e:\n                print(f\"Failed: {bed_file.name} - {e}\")\n\n    return all_results\n\n\n# Process with 3 parallel workers\n# Note: Be careful not to exceed GREAT's rate limits\nresults = process_parallel(\"samples/\", max_workers=3)\n</code></pre>"},{"location":"examples/advanced/#example-6-custom-visualization","title":"Example 6: Custom Visualization","text":"<p>Create a custom volcano-style plot.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pygreat import GreatClient\n\n\nwith GreatClient() as client:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\n    results = job.get_enrichment_tables()\n\ngo_bp = results[\"GO Biological Process\"]\n\n# Create volcano-style plot\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# Transform data\nx = go_bp[\"binom_fold_enrichment\"]\ny = -np.log10(go_bp[\"binom_fdr\"])\n\n# Color by significance\ncolors = np.where(go_bp[\"binom_fdr\"] &lt; 0.05, \"red\", \"gray\")\n\n# Size by gene count\nsizes = go_bp[\"observed_genes\"] * 3\n\nax.scatter(x, y, c=colors, s=sizes, alpha=0.6)\n\n# Add labels for top terms\ntop_terms = go_bp.nsmallest(5, \"binom_fdr\")\nfor _, row in top_terms.iterrows():\n    ax.annotate(\n        row[\"term_name\"][:40],\n        (row[\"binom_fold_enrichment\"], -np.log10(row[\"binom_fdr\"])),\n        fontsize=8,\n        ha=\"left\",\n    )\n\nax.set_xlabel(\"Fold Enrichment\")\nax.set_ylabel(\"-log10(FDR)\")\nax.set_title(\"GO Biological Process Enrichment\")\nax.axhline(-np.log10(0.05), color=\"red\", linestyle=\"--\", alpha=0.5)\n\nplt.tight_layout()\nplt.savefig(\"volcano_plot.png\", dpi=300)\n</code></pre>"},{"location":"examples/advanced/#example-7-export-to-excel-with-formatting","title":"Example 7: Export to Excel with Formatting","text":"<p>Create a formatted Excel report.</p> <pre><code>import pandas as pd\nfrom pygreat import GreatClient\n\n\nwith GreatClient() as client:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\n    results = job.get_enrichment_tables(max_fdr=0.1)\n\n# Create Excel writer with formatting\nwith pd.ExcelWriter(\"report.xlsx\", engine=\"openpyxl\") as writer:\n    # Write summary sheet\n    summary_data = []\n    for ont, df in results.items():\n        n_sig = (df[\"binom_fdr\"] &lt; 0.05).sum() if not df.empty else 0\n        summary_data.append({\"Ontology\": ont, \"Significant Terms\": n_sig})\n\n    summary_df = pd.DataFrame(summary_data)\n    summary_df.to_excel(writer, sheet_name=\"Summary\", index=False)\n\n    # Write each ontology\n    for ont, df in results.items():\n        if not df.empty:\n            sheet_name = ont[:31]  # Excel sheet name limit\n            df.to_excel(writer, sheet_name=sheet_name, index=False)\n\nprint(\"Saved report.xlsx\")\n</code></pre>"},{"location":"examples/advanced/#example-8-integration-with-pyranges","title":"Example 8: Integration with PyRanges","text":"<p>Convert between pygreat and PyRanges.</p> <pre><code>import pyranges as pr\nfrom pygreat import GreatClient\nfrom pygreat.models import GenomicRegions\n\n\n# Load with PyRanges\npeaks = pr.read_bed(\"peaks.bed\")\n\n# Filter using PyRanges features\npeaks = peaks[peaks.lengths() &gt;= 200]\npeaks = peaks.merge()  # Merge overlapping\n\n# Convert to DataFrame for pygreat\ndf = peaks.df.rename(columns={\n    \"Chromosome\": \"chrom\",\n    \"Start\": \"start\",\n    \"End\": \"end\",\n})\n\n# Run GREAT\nwith GreatClient() as client:\n    job = client.submit_job(df, species=\"hg38\")\n    results = job.get_enrichment_tables()\n</code></pre>"},{"location":"examples/advanced/#example-9-caching-results","title":"Example 9: Caching Results","text":"<p>Cache GREAT results for repeated analysis.</p> <pre><code>import json\nimport hashlib\nfrom pathlib import Path\nfrom pygreat import GreatClient\n\n\ndef get_cache_key(bed_file, species, rule):\n    \"\"\"Generate cache key from parameters.\"\"\"\n    content = Path(bed_file).read_bytes()\n    h = hashlib.md5(content).hexdigest()\n    return f\"{species}_{rule}_{h[:8]}\"\n\n\ndef run_great_cached(bed_file, species=\"hg38\", rule=\"basalPlusExt\"):\n    \"\"\"Run GREAT with caching.\"\"\"\n    cache_dir = Path(\".great_cache\")\n    cache_dir.mkdir(exist_ok=True)\n\n    cache_key = get_cache_key(bed_file, species, rule)\n    cache_file = cache_dir / f\"{cache_key}.parquet\"\n\n    if cache_file.exists():\n        print(f\"Loading from cache: {cache_key}\")\n        return pd.read_parquet(cache_file)\n\n    print(f\"Running GREAT analysis...\")\n    with GreatClient() as client:\n        job = client.submit_job(bed_file, species=species, rule=rule)\n        df = job.to_dataframe()\n\n    # Cache results\n    df.to_parquet(cache_file)\n    print(f\"Cached: {cache_key}\")\n\n    return df\n\n\n# First run: hits GREAT server\nresults = run_great_cached(\"peaks.bed\", species=\"hg38\")\n\n# Second run: loads from cache\nresults = run_great_cached(\"peaks.bed\", species=\"hg38\")\n</code></pre>"},{"location":"examples/advanced/#example-10-command-line-script","title":"Example 10: Command Line Script","text":"<p>A complete command-line analysis script.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nGREAT enrichment analysis script.\n\nUsage:\n    python analyze.py peaks.bed -s hg38 -o results/\n\"\"\"\n\nimport argparse\nfrom pathlib import Path\nfrom pygreat import GreatClient\nfrom pygreat.viz import plot_enrichment_bar, plot_enrichment_dot\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Run GREAT enrichment analysis\"\n    )\n    parser.add_argument(\"bed_file\", help=\"Input BED file\")\n    parser.add_argument(\"-s\", \"--species\", default=\"hg38\",\n                        choices=[\"hg38\", \"hg19\", \"mm10\", \"mm9\"])\n    parser.add_argument(\"-o\", \"--output\", default=\".\", help=\"Output directory\")\n    parser.add_argument(\"--max-fdr\", type=float, default=0.05)\n    parser.add_argument(\"--min-genes\", type=int, default=3)\n    parser.add_argument(\"-n\", \"--n-terms\", type=int, default=15)\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n    output_dir = Path(args.output)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    print(f\"Analyzing {args.bed_file}...\")\n\n    with GreatClient() as client:\n        job = client.submit_job(args.bed_file, species=args.species)\n        results = job.get_enrichment_tables(\n            max_fdr=args.max_fdr,\n            min_genes=args.min_genes,\n        )\n\n        # Save all results\n        df = job.to_dataframe()\n        df.to_csv(output_dir / \"all_results.tsv\", sep=\"\\t\", index=False)\n\n        # Create plots for each ontology\n        for ont, ont_df in results.items():\n            if ont_df.empty:\n                continue\n\n            safe_name = ont.replace(\" \", \"_\").lower()\n\n            # Bar plot\n            fig, ax = plot_enrichment_bar(ont_df, n_terms=args.n_terms, title=ont)\n            fig.savefig(output_dir / f\"{safe_name}_bar.png\", dpi=300, bbox_inches=\"tight\")\n            plt.close(fig)\n\n            # Dot plot\n            fig, ax = plot_enrichment_dot(ont_df, n_terms=args.n_terms, title=ont)\n            fig.savefig(output_dir / f\"{safe_name}_dot.png\", dpi=300, bbox_inches=\"tight\")\n            plt.close(fig)\n\n            print(f\"  {ont}: {len(ont_df)} terms\")\n\n    print(f\"\\nResults saved to {output_dir}/\")\n\n\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n    main()\n</code></pre>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>This page provides complete examples for common pygreat use cases.</p>"},{"location":"examples/basic/#example-1-simple-enrichment-analysis","title":"Example 1: Simple Enrichment Analysis","text":"<p>Submit a BED file and get enrichment results.</p> <pre><code>from pygreat import GreatClient\n\n# Create client\nclient = GreatClient()\n\n# Submit job\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Get all results\nresults = job.get_enrichment_tables()\n\n# Print summary\nfor ontology, df in results.items():\n    n_sig = (df[\"binom_fdr\"] &lt; 0.05).sum()\n    print(f\"{ontology}: {n_sig} significant terms\")\n\n# Access GO Biological Process\ngo_bp = results[\"GO Biological Process\"]\n\n# Show top 10 terms\ntop10 = go_bp.nsmallest(10, \"binom_fdr\")\nprint(top10[[\"term_name\", \"binom_fdr\", \"observed_genes\"]])\n\n# Clean up\nclient.close()\n</code></pre>"},{"location":"examples/basic/#example-2-from-a-dataframe","title":"Example 2: From a DataFrame","text":"<p>Analyze regions from a pandas DataFrame.</p> <pre><code>import pandas as pd\nfrom pygreat import GreatClient\n\n# Create regions DataFrame\nregions = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr1\", \"chr2\", \"chr3\", \"chr5\"],\n    \"start\": [1000000, 5000000, 10000000, 15000000, 20000000],\n    \"end\": [1001000, 5001000, 10001000, 15001000, 20001000],\n    \"name\": [\"peak1\", \"peak2\", \"peak3\", \"peak4\", \"peak5\"],\n})\n\n# Submit and analyze\nwith GreatClient() as client:\n    job = client.submit_job(regions, species=\"hg38\")\n    results = job.get_enrichment_tables(max_fdr=0.05)\n\n    # Check results\n    if results:\n        for ont, df in results.items():\n            if not df.empty:\n                print(f\"\\n{ont}:\")\n                print(df[[\"term_name\", \"binom_fdr\"]].head())\n</code></pre>"},{"location":"examples/basic/#example-3-from-a-url","title":"Example 3: From a URL","text":"<p>Analyze a publicly accessible BED file.</p> <pre><code>from pygreat import GreatClient\n\n# URL to a public BED file (no upload needed)\nurl = \"https://example.com/data/chipseq_peaks.bed\"\n\nwith GreatClient() as client:\n    job = client.submit_job(url, species=\"hg38\")\n    results = job.get_enrichment_tables()\n\n    # Process results\n    go_bp = results.get(\"GO Biological Process\")\n    if go_bp is not None:\n        significant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n        print(f\"Found {len(significant)} significant GO terms\")\n</code></pre>"},{"location":"examples/basic/#example-4-with-background-regions","title":"Example 4: With Background Regions","text":"<p>Perform foreground/background analysis.</p> <pre><code>from pygreat import GreatClient\n\n# Foreground: your peaks of interest\n# Background: all possible peaks (e.g., from different conditions)\n\nwith GreatClient() as client:\n    job = client.submit_job(\n        \"treatment_peaks.bed\",\n        species=\"hg38\",\n        background=\"all_accessible_regions.bed\",\n    )\n\n    results = job.get_enrichment_tables(max_fdr=0.05)\n\n    # This tests enrichment relative to background,\n    # not the whole genome\n</code></pre>"},{"location":"examples/basic/#example-5-filter-and-export","title":"Example 5: Filter and Export","text":"<p>Filter results and save to files.</p> <pre><code>from pygreat import GreatClient\n\nwith GreatClient() as client:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n    # Get filtered results\n    results = job.get_enrichment_tables(\n        max_fdr=0.05,\n        min_genes=5,\n    )\n\n    # Export all results to single TSV\n    df = job.to_dataframe()\n    df.to_csv(\"all_results.tsv\", sep=\"\\t\", index=False)\n\n    # Export each ontology separately\n    for ontology, df in results.items():\n        if not df.empty:\n            # Create safe filename\n            filename = ontology.replace(\" \", \"_\").lower() + \".tsv\"\n            df.to_csv(filename, sep=\"\\t\", index=False)\n            print(f\"Saved {len(df)} terms to {filename}\")\n</code></pre>"},{"location":"examples/basic/#example-6-simple-visualization","title":"Example 6: Simple Visualization","text":"<p>Create a bar plot of enrichment results.</p> <pre><code>from pygreat import GreatClient\nfrom pygreat.viz import plot_enrichment_bar\n\n# Get results\nclient = GreatClient()\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\nresults = job.get_enrichment_tables()\nclient.close()\n\n# Get significant GO terms\ngo_bp = results[\"GO Biological Process\"]\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n\n# Create plot\nfig, ax = plot_enrichment_bar(\n    significant,\n    n_terms=15,\n    title=\"GO Biological Process Enrichment\",\n)\n\n# Save\nfig.savefig(\"enrichment.png\", dpi=300, bbox_inches=\"tight\")\nprint(\"Saved enrichment.png\")\n</code></pre>"},{"location":"examples/basic/#example-7-different-species","title":"Example 7: Different Species","text":"<p>Analyze mouse data.</p> <pre><code>from pygreat import GreatClient\n\n# Mouse mm10 assembly\nwith GreatClient() as client:\n    job = client.submit_job(\n        \"mouse_peaks.bed\",\n        species=\"mm10\",\n    )\n\n    results = job.get_enrichment_tables()\n\n    # Check metadata\n    meta = job.get_metadata()\n    print(f\"Species: {meta['species']}\")\n    print(f\"GREAT version: {meta['version']}\")\n</code></pre>"},{"location":"examples/basic/#example-8-different-association-rules","title":"Example 8: Different Association Rules","text":"<p>Compare different gene association rules.</p> <pre><code>from pygreat import GreatClient\n\nrules = [\"basalPlusExt\", \"twoClosest\", \"oneClosest\"]\n\nwith GreatClient() as client:\n    for rule in rules:\n        job = client.submit_job(\n            \"peaks.bed\",\n            species=\"hg38\",\n            rule=rule,\n        )\n\n        results = job.get_enrichment_tables(max_fdr=0.05)\n        go_bp = results.get(\"GO Biological Process\")\n\n        n_terms = len(go_bp) if go_bp is not None else 0\n        print(f\"{rule}: {n_terms} significant GO BP terms\")\n</code></pre>"},{"location":"examples/basic/#example-9-error-handling","title":"Example 9: Error Handling","text":"<p>Handle common errors gracefully.</p> <pre><code>from pygreat import GreatClient\nfrom pygreat.core.exceptions import (\n    InvalidSpeciesError,\n    RateLimitError,\n    GreatError,\n)\n\ndef analyze_peaks(bed_file, species):\n    \"\"\"Analyze peaks with error handling.\"\"\"\n    client = GreatClient()\n\n    try:\n        job = client.submit_job(bed_file, species=species)\n        return job.get_enrichment_tables()\n\n    except InvalidSpeciesError:\n        print(f\"Error: '{species}' is not a valid species.\")\n        print(\"Valid options: hg38, hg19, mm10, mm9\")\n        return None\n\n    except RateLimitError:\n        print(\"Error: GREAT server is busy. Try again later.\")\n        return None\n\n    except GreatError as e:\n        print(f\"Error: {e}\")\n        return None\n\n    finally:\n        client.close()\n\n# Use it\nresults = analyze_peaks(\"peaks.bed\", \"hg38\")\nif results:\n    print(\"Analysis complete!\")\n</code></pre>"},{"location":"examples/basic/#example-10-complete-workflow","title":"Example 10: Complete Workflow","text":"<p>A complete analysis script.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Complete GREAT enrichment analysis.\"\"\"\n\nfrom pathlib import Path\nfrom pygreat import GreatClient\nfrom pygreat.viz import plot_enrichment_bar, plot_enrichment_dot\n\n\ndef main():\n    # Configuration\n    bed_file = \"peaks.bed\"\n    species = \"hg38\"\n    output_dir = Path(\"results\")\n    output_dir.mkdir(exist_ok=True)\n\n    # Run analysis\n    print(f\"Analyzing {bed_file}...\")\n\n    with GreatClient() as client:\n        job = client.submit_job(bed_file, species=species)\n\n        # Get filtered results\n        results = job.get_enrichment_tables(max_fdr=0.05, min_genes=3)\n\n        # Save results\n        df = job.to_dataframe()\n        df.to_csv(output_dir / \"all_results.tsv\", sep=\"\\t\", index=False)\n        print(f\"Saved results to {output_dir / 'all_results.tsv'}\")\n\n        # Create visualizations for GO terms\n        for ont in [\"GO Biological Process\", \"GO Molecular Function\"]:\n            ont_df = results.get(ont)\n            if ont_df is not None and not ont_df.empty:\n                # Bar plot\n                fig, ax = plot_enrichment_bar(ont_df, n_terms=15, title=ont)\n                filename = ont.replace(\" \", \"_\").lower() + \"_bar.png\"\n                fig.savefig(output_dir / filename, dpi=300, bbox_inches=\"tight\")\n                print(f\"Saved {filename}\")\n\n                # Dot plot\n                fig, ax = plot_enrichment_dot(ont_df, n_terms=15, title=ont)\n                filename = ont.replace(\" \", \"_\").lower() + \"_dot.png\"\n                fig.savefig(output_dir / filename, dpi=300, bbox_inches=\"tight\")\n                print(f\"Saved {filename}\")\n\n    print(\"Done!\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip (Python package manager)</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install pygreat is via pip:</p> <pre><code>pip install py-great\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>For the latest development version:</p> <pre><code>git clone https://github.com/khan-lab/pyGREAT.git\ncd pygreat\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>pygreat automatically installs the following dependencies:</p> Package Purpose <code>httpx</code> HTTP client for API requests <code>pandas</code> DataFrame handling for results <code>numpy</code> Numerical operations <code>rich-click</code> Beautiful CLI interface <code>rich</code> Terminal formatting <code>matplotlib</code> Plotting backend <code>seaborn</code> Statistical visualizations"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development and testing:</p> <pre><code>pip install py-great[dev]\n</code></pre> <p>This includes:</p> <ul> <li><code>pytest</code> - Testing framework</li> <li><code>pytest-cov</code> - Coverage reporting</li> <li><code>mypy</code> - Static type checking</li> <li><code>ruff</code> - Linting</li> </ul>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify pygreat is working:</p> <pre><code>&gt;&gt;&gt; from pygreat import GreatClient\n&gt;&gt;&gt; client = GreatClient()\n&gt;&gt;&gt; print(f\"pygreat ready, using GREAT v{client.version}\")\npygreat ready, using GREAT v4.0.4\n</code></pre> <p>Or via the command line:</p> <pre><code>pygreat --version\n</code></pre>"},{"location":"getting-started/installation/#network-requirements","title":"Network Requirements","text":"<p>pygreat requires network access to:</p> <ol> <li>GREAT server (<code>great.stanford.edu</code>) - For submitting jobs and retrieving results</li> <li>File hosting (<code>transfer.sh</code>) - For uploading local BED files (only when not using URLs)</li> </ol> <p>Ensure these domains are accessible from your network.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with pygreat in just a few minutes.</p>"},{"location":"getting-started/quickstart/#basic-workflow","title":"Basic Workflow","text":"<p>The typical pygreat workflow is:</p> <ol> <li>Create a <code>GreatClient</code></li> <li>Submit genomic regions with <code>submit_job()</code></li> <li>Retrieve enrichment results</li> <li>Analyze or visualize the results</li> </ol>"},{"location":"getting-started/quickstart/#from-a-bed-file","title":"From a BED File","text":"<p>The most common use case is submitting a local BED file:</p> <pre><code>from pygreat import GreatClient\n\n# Create client\nclient = GreatClient()\n\n# Submit job\njob = client.submit_job(\n    \"peaks.bed\",      # Your BED file\n    species=\"hg38\",   # Genome assembly\n)\n\n# Get all enrichment results\nresults = job.get_enrichment_tables()\n\n# Access specific ontology\ngo_bp = results[\"GO Biological Process\"]\nprint(go_bp.head())\n</code></pre>"},{"location":"getting-started/quickstart/#from-a-url","title":"From a URL","text":"<p>If your BED file is publicly accessible online, you can use the URL directly (no file upload needed):</p> <pre><code>from pygreat import GreatClient\n\nclient = GreatClient()\njob = client.submit_job(\n    \"https://example.com/peaks.bed\",\n    species=\"hg38\",\n)\nresults = job.get_enrichment_tables()\n</code></pre>"},{"location":"getting-started/quickstart/#from-a-dataframe","title":"From a DataFrame","text":"<p>You can also submit regions directly from a pandas DataFrame:</p> <pre><code>import pandas as pd\nfrom pygreat import GreatClient\n\n# Create regions DataFrame\nregions = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr1\", \"chr2\", \"chr3\"],\n    \"start\": [1000, 5000, 10000, 15000],\n    \"end\": [2000, 6000, 11000, 16000],\n})\n\nclient = GreatClient()\njob = client.submit_job(regions, species=\"hg38\")\nresults = job.get_enrichment_tables()\n</code></pre>"},{"location":"getting-started/quickstart/#filter-significant-terms","title":"Filter Significant Terms","text":"<p>Filter results by FDR threshold and minimum gene count:</p> <pre><code># Get results with filtering\nresults = job.get_enrichment_tables(\n    max_fdr=0.05,      # FDR &lt; 0.05\n    min_genes=5,       # At least 5 genes\n)\n\n# Or filter after retrieval\ngo_bp = results[\"GO Biological Process\"]\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n</code></pre>"},{"location":"getting-started/quickstart/#visualize-results","title":"Visualize Results","text":"<p>Create a bar plot of the top enriched terms:</p> <pre><code>from pygreat.viz import plot_enrichment_bar\n\n# Get significant GO terms\ngo_bp = results[\"GO Biological Process\"]\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n\n# Create bar plot\nfig, ax = plot_enrichment_bar(\n    significant,\n    n_terms=15,\n    title=\"GO Biological Process Enrichment\",\n)\nfig.savefig(\"enrichment.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"getting-started/quickstart/#export-results","title":"Export Results","text":"<p>Save results to a TSV file:</p> <pre><code># Export all ontologies (adds 'ontology' column)\ndf = job.to_dataframe()\ndf.to_csv(\"all_results.tsv\", sep=\"\\t\", index=False)\n\n# Export single ontology\ngo_bp = job.to_dataframe(\"GO Biological Process\")\ngo_bp.to_csv(\"go_bp_results.tsv\", sep=\"\\t\", index=False)\n</code></pre>"},{"location":"getting-started/quickstart/#using-the-cli","title":"Using the CLI","text":"<p>For quick analysis, use the command-line interface:</p> <pre><code># Submit job and save results\npygreat submit peaks.bed --species hg38 --output results.tsv\n\n# Filter by FDR\npygreat submit peaks.bed -s hg38 --max-fdr 0.05 -o results.tsv\n\n# Create visualization\npygreat plot results.tsv -t \"GO Biological Process\" -o plot.png\n</code></pre>"},{"location":"getting-started/quickstart/#context-manager","title":"Context Manager","text":"<p>Use the context manager pattern to ensure proper cleanup:</p> <pre><code>from pygreat import GreatClient\n\nwith GreatClient() as client:\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\n    results = job.get_enrichment_tables()\n    # Process results...\n# Client is automatically closed\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about different input formats</li> <li>Explore working with results</li> <li>Create visualizations</li> <li>See the full API reference</li> </ul>"},{"location":"guide/cli/","title":"CLI Reference","text":"<p>pygreat provides a command-line interface for quick enrichment analysis without writing Python code.</p>"},{"location":"guide/cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with pygreat:</p> <pre><code>pip install pygreat\n</code></pre>"},{"location":"guide/cli/#global-options","title":"Global Options","text":"<pre><code>pygreat [OPTIONS] COMMAND [ARGS]\n</code></pre> Option Description <code>-v, --verbose</code> Enable verbose output <code>--version</code> Show version and exit <code>--help</code> Show help message"},{"location":"guide/cli/#commands","title":"Commands","text":""},{"location":"guide/cli/#submit","title":"submit","text":"<p>Submit genomic regions to GREAT for enrichment analysis.</p> <pre><code>pygreat submit [OPTIONS] REGIONS\n</code></pre> <p>Arguments:</p> Argument Description <code>REGIONS</code> Path to BED file or URL to public BED file <p>Options:</p> Option Default Description <code>-s, --species</code> <code>hg38</code> Genome assembly (hg38, hg19, mm10, mm9) <code>-o, --output</code> stdout Output TSV file path <code>-b, --background</code> None Background regions file or URL <code>-r, --rule</code> <code>basalPlusExt</code> Association rule <code>--max-fdr</code> 1.0 Maximum FDR threshold <code>--min-genes</code> 1 Minimum observed genes <code>-t, --ontologies</code> all Ontologies to include (can repeat) <p>Examples:</p> <pre><code># Basic usage\npygreat submit peaks.bed --species hg38 --output results.tsv\n\n# Short form\npygreat submit peaks.bed -s hg38 -o results.tsv\n\n# From URL\npygreat submit https://example.com/peaks.bed -s hg38 -o results.tsv\n\n# With background\npygreat submit peaks.bed -s hg38 -b background.bed -o results.tsv\n\n# Filter results\npygreat submit peaks.bed -s hg38 --max-fdr 0.05 --min-genes 5 -o results.tsv\n\n# Specific ontologies\npygreat submit peaks.bed -s hg38 -t \"GO Biological Process\" -t \"KEGG Pathway\" -o results.tsv\n\n# Verbose mode\npygreat -v submit peaks.bed -s hg38 -o results.tsv\n\n# Different association rule\npygreat submit peaks.bed -s hg38 --rule twoClosest -o results.tsv\n</code></pre>"},{"location":"guide/cli/#plot","title":"plot","text":"<p>Create visualization from enrichment results.</p> <pre><code>pygreat plot [OPTIONS] RESULTS\n</code></pre> <p>Arguments:</p> Argument Description <code>RESULTS</code> Path to TSV file from <code>submit</code> command <p>Options:</p> Option Default Description <code>-t, --ontology</code> Required Ontology to plot <code>-o, --output</code> Required Output image file path <code>--plot-type</code> <code>bar</code> Plot type: <code>bar</code> or <code>dot</code> <code>-n, --n-terms</code> 15 Number of top terms to show <code>--title</code> ontology name Plot title <code>--width</code> 10 Figure width in inches <code>--height</code> 8 Figure height in inches <code>--dpi</code> 300 Image resolution <p>Examples:</p> <pre><code># Bar plot\npygreat plot results.tsv -t \"GO Biological Process\" -o barplot.png\n\n# Dot plot\npygreat plot results.tsv -t \"GO Biological Process\" --plot-type dot -o dotplot.png\n\n# Custom number of terms\npygreat plot results.tsv -t \"GO Biological Process\" -n 20 -o barplot.png\n\n# Custom title\npygreat plot results.tsv -t \"GO Biological Process\" --title \"ChIP-seq Enrichment\" -o plot.png\n\n# High resolution\npygreat plot results.tsv -t \"GO Biological Process\" --dpi 600 -o print_quality.png\n\n# PDF output\npygreat plot results.tsv -t \"GO Biological Process\" -o plot.pdf\n\n# Custom size\npygreat plot results.tsv -t \"GO Biological Process\" --width 12 --height 10 -o wide_plot.png\n</code></pre>"},{"location":"guide/cli/#report","title":"report","text":"<p>Generate an interactive HTML report from enrichment results.</p> <pre><code>pygreat report [OPTIONS] RESULTS_FILE\n</code></pre> <p>Arguments:</p> Argument Description <code>RESULTS_FILE</code> Path to TSV/CSV file from <code>submit</code> or <code>local</code> command <p>Options:</p> Option Default Description <code>-o, --output</code> Required Output HTML file path <code>-t, --title</code> \"GREAT Enrichment Report\" Report title <code>--fdr-threshold</code> 0.05 Default FDR threshold for filtering <code>--top-n</code> 100 Default number of top terms to display <p>Report Features:</p> <ul> <li>Summary Panel - Overview with total terms, significant terms per ontology</li> <li>Interactive Tables - Search, sort, pagination with DataTables</li> <li>Global Filters - FDR threshold, p-value threshold, Top N, category filter</li> <li>Term Detail Modal - Click any term to see full statistics, gene list, GO links</li> <li>Plot Builder - Create bar or dot plots from selected terms</li> <li>Export Options - Download plots (SVG/PNG) and data (TSV/CSV)</li> </ul> <p>Examples:</p> <pre><code># Basic report\npygreat report results.tsv -o report.html\n\n# Custom title\npygreat report results.tsv -o report.html -t \"ChIP-seq Analysis\"\n\n# Stricter FDR default\npygreat report results.tsv -o report.html --fdr-threshold 0.01\n\n# Show fewer terms by default\npygreat report results.tsv -o report.html --top-n 20\n</code></pre>"},{"location":"guide/cli/#local","title":"local","text":"<p>Run GREAT enrichment analysis locally without the web service.</p> <pre><code>pygreat local [OPTIONS] REGIONS\n</code></pre> <p>Arguments:</p> Argument Description <code>REGIONS</code> Path to BED file with genomic regions <p>Options:</p> Option Default Description <code>--gtf</code> Required Path to GTF gene annotation file <code>--gmt</code> Required Path to GMT gene set file(s), can repeat <code>--chrom-sizes</code> None Chromosome sizes file (optional) <code>-o, --output</code> stdout Output TSV file path <code>--upstream</code> 5000 Basal upstream extension (bp) <code>--downstream</code> 1000 Basal downstream extension (bp) <code>--max-extension</code> 1000000 Maximum extension (bp) <code>--max-fdr</code> 1.0 Maximum FDR threshold <code>--min-genes</code> 1 Minimum observed genes <p>Examples:</p> <pre><code># Basic local analysis\npygreat local peaks.bed --gtf genes.gtf --gmt go_terms.gmt -o results.tsv\n\n# Multiple gene set files\npygreat local peaks.bed --gtf genes.gtf --gmt go_bp.gmt --gmt go_mf.gmt -o results.tsv\n\n# Custom regulatory domain\npygreat local peaks.bed --gtf genes.gtf --gmt terms.gmt \\\n    --upstream 10000 --downstream 2000 --max-extension 500000 -o results.tsv\n\n# Filter results\npygreat local peaks.bed --gtf genes.gtf --gmt terms.gmt \\\n    --max-fdr 0.05 --min-genes 3 -o results.tsv\n</code></pre>"},{"location":"guide/cli/#output-format","title":"Output Format","text":"<p>The <code>submit</code> command outputs a TSV file with these columns:</p> <pre><code>ontology  term_id  term_name  binom_rank  binom_p  binom_fdr  ...\n</code></pre> <p>When writing to stdout (no <code>-o</code> option), results are formatted as a table.</p>"},{"location":"guide/cli/#exit-codes","title":"Exit Codes","text":"Code Description 0 Success 1 General error 2 Invalid arguments"},{"location":"guide/cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>PYGREAT_TIMEOUT</code> Request timeout in seconds (default: 300) <code>PYGREAT_MAX_RETRIES</code> Maximum retry attempts (default: 5)"},{"location":"guide/cli/#examples","title":"Examples","text":""},{"location":"guide/cli/#complete-workflow","title":"Complete Workflow","text":"<pre><code># 1. Submit job and save results\npygreat -v submit peaks.bed -s hg38 --max-fdr 0.05 -o results.tsv\n\n# 2. Create bar plot\npygreat plot results.tsv -t \"GO Biological Process\" -o go_bp_bar.png\n\n# 3. Create dot plot\npygreat plot results.tsv -t \"GO Biological Process\" --plot-type dot -o go_bp_dot.png\n\n# 4. Generate interactive HTML report\npygreat report results.tsv -o report.html\n</code></pre>"},{"location":"guide/cli/#local-analysis-workflow","title":"Local Analysis Workflow","text":"<pre><code># 1. Run local enrichment analysis\npygreat local peaks.bed --gtf gencode.gtf --gmt go_terms.gmt -o results.tsv\n\n# 2. Generate interactive report\npygreat report results.tsv -o report.html -t \"Local GREAT Analysis\"\n</code></pre>"},{"location":"guide/cli/#batch-processing","title":"Batch Processing","text":"<pre><code># Process multiple samples\nfor bed in samples/*.bed; do\n    name=$(basename \"$bed\" .bed)\n    pygreat submit \"$bed\" -s hg38 --max-fdr 0.05 -o \"results/${name}.tsv\"\n    pygreat plot \"results/${name}.tsv\" -t \"GO Biological Process\" -o \"plots/${name}.png\"\ndone\n</code></pre>"},{"location":"guide/cli/#piping-results","title":"Piping Results","text":"<pre><code># View results without saving\npygreat submit peaks.bed -s hg38 | head -50\n\n# Filter with standard tools\npygreat submit peaks.bed -s hg38 | grep \"GO Biological Process\" | head -20\n</code></pre>"},{"location":"guide/results/","title":"Working with Results","text":"<p>After submitting a job, pygreat returns a <code>GreatJob</code> object containing all enrichment results. This guide covers how to access, filter, and export these results.</p>"},{"location":"guide/results/#retrieving-enrichment-tables","title":"Retrieving Enrichment Tables","text":""},{"location":"guide/results/#get-all-ontologies","title":"Get All Ontologies","text":"<pre><code>from pygreat import GreatClient\n\nclient = GreatClient()\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Get all enrichment results\nresults = job.get_enrichment_tables()\n\n# results is a dict: ontology name -&gt; DataFrame\nfor ontology, df in results.items():\n    print(f\"{ontology}: {len(df)} terms\")\n</code></pre>"},{"location":"guide/results/#get-specific-ontologies","title":"Get Specific Ontologies","text":"<pre><code># Request specific ontologies\nresults = job.get_enrichment_tables(\n    ontologies=[\"GO Biological Process\", \"GO Molecular Function\"]\n)\n</code></pre>"},{"location":"guide/results/#get-single-ontology","title":"Get Single Ontology","text":"<pre><code># Get one ontology directly\ngo_bp = job.get_enrichment_table(\"GO Biological Process\")\n</code></pre>"},{"location":"guide/results/#available-ontologies","title":"Available Ontologies","text":"<p>List all available ontologies in the results:</p> <pre><code># Flat list\nontologies = job.list_ontologies()\nprint(ontologies)\n# ['GO Biological Process', 'GO Molecular Function', 'GO Cellular Component', ...]\n\n# Grouped by category\ncategories = job.available_ontologies()\nfor category, names in categories.items():\n    print(f\"{category}: {names}\")\n</code></pre>"},{"location":"guide/results/#filtering-results","title":"Filtering Results","text":""},{"location":"guide/results/#by-fdr-threshold","title":"By FDR Threshold","text":"<p>Filter to significant terms:</p> <pre><code># During retrieval\nresults = job.get_enrichment_tables(max_fdr=0.05)\n\n# After retrieval\ngo_bp = results[\"GO Biological Process\"]\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n</code></pre>"},{"location":"guide/results/#by-gene-count","title":"By Gene Count","text":"<p>Filter by minimum number of observed genes:</p> <pre><code># During retrieval\nresults = job.get_enrichment_tables(min_genes=5)\n\n# After retrieval\ngo_bp = results[\"GO Biological Process\"]\nfiltered = go_bp[go_bp[\"observed_genes\"] &gt;= 5]\n</code></pre>"},{"location":"guide/results/#combined-filtering","title":"Combined Filtering","text":"<pre><code># Both filters\nresults = job.get_enrichment_tables(\n    max_fdr=0.05,\n    min_genes=5,\n)\n\n# Or chain pandas filters\ngo_bp = results[\"GO Biological Process\"]\nfiltered = go_bp[\n    (go_bp[\"binom_fdr\"] &lt; 0.05) &amp;\n    (go_bp[\"observed_genes\"] &gt;= 5)\n]\n</code></pre>"},{"location":"guide/results/#dataframe-columns","title":"DataFrame Columns","text":"<p>Each enrichment DataFrame contains these columns:</p> Column Type Description <code>term_id</code> str Ontology term ID (e.g., GO:0006915) <code>term_name</code> str Human-readable term name <code>binom_rank</code> int Binomial test rank <code>binom_p</code> float Binomial raw p-value <code>binom_bonferroni</code> float Bonferroni-corrected p-value <code>binom_fdr</code> float FDR-corrected q-value <code>binom_fold_enrichment</code> float Fold enrichment (binomial) <code>observed_regions</code> int Number of input regions for term <code>expected_regions</code> float Expected regions under null <code>genome_fraction</code> float Fraction of genome annotated to term <code>region_coverage</code> float Fraction of input regions annotated <code>hyper_rank</code> int Hypergeometric test rank <code>hyper_p</code> float Hypergeometric raw p-value <code>hyper_bonferroni</code> float Bonferroni-corrected (hyper) <code>hyper_fdr</code> float FDR-corrected (hyper) <code>hyper_fold_enrichment</code> float Fold enrichment (hyper) <code>observed_genes</code> int Number of genes in input regions <code>expected_genes</code> float Expected genes under null <code>total_genes</code> int Total genes annotated to term <code>gene_coverage</code> float Fraction of term genes observed <code>term_coverage</code> float Fraction of term covered <code>regions</code> str Comma-separated region names <code>genes</code> str Comma-separated gene names"},{"location":"guide/results/#sorting-results","title":"Sorting Results","text":"<pre><code>go_bp = results[\"GO Biological Process\"]\n\n# Sort by binomial FDR (most significant first)\nsorted_df = go_bp.sort_values(\"binom_fdr\")\n\n# Sort by fold enrichment (highest first)\nsorted_df = go_bp.sort_values(\"binom_fold_enrichment\", ascending=False)\n\n# Sort by gene count\nsorted_df = go_bp.sort_values(\"observed_genes\", ascending=False)\n</code></pre>"},{"location":"guide/results/#accessing-metadata","title":"Accessing Metadata","text":"<p>Get information about the job:</p> <pre><code># Job metadata\nmetadata = job.get_metadata()\nprint(metadata)\n# {'version': '4.0.4', 'species': 'hg38', 'rule': 'Basal+extension: ...'}\n\n# Ontology statistics\nstats = job.get_ontology_stats()\nprint(stats[\"GO Biological Process\"])\n# {'terms_tested': 13145, 'min_annot_count': '1', 'max_annot_count': 'Inf'}\n</code></pre>"},{"location":"guide/results/#exporting-results","title":"Exporting Results","text":""},{"location":"guide/results/#to-tsv-file","title":"To TSV File","text":"<pre><code># Export all ontologies (includes 'ontology' column)\ndf = job.to_dataframe()\ndf.to_csv(\"all_results.tsv\", sep=\"\\t\", index=False)\n\n# Export single ontology\ngo_bp = job.to_dataframe(\"GO Biological Process\")\ngo_bp.to_csv(\"go_bp_results.tsv\", sep=\"\\t\", index=False)\n</code></pre>"},{"location":"guide/results/#to-excel","title":"To Excel","text":"<pre><code># Export to Excel with multiple sheets\nwith pd.ExcelWriter(\"results.xlsx\") as writer:\n    for ontology, df in results.items():\n        # Truncate sheet name to Excel's limit\n        sheet_name = ontology[:31]\n        df.to_excel(writer, sheet_name=sheet_name, index=False)\n</code></pre>"},{"location":"guide/results/#to-csv","title":"To CSV","text":"<pre><code>go_bp = results[\"GO Biological Process\"]\ngo_bp.to_csv(\"go_bp.csv\", index=False)\n</code></pre>"},{"location":"guide/results/#common-analysis-patterns","title":"Common Analysis Patterns","text":""},{"location":"guide/results/#top-n-terms","title":"Top N Terms","text":"<pre><code># Top 10 by significance\ntop10 = go_bp.nsmallest(10, \"binom_fdr\")\n\n# Top 10 by fold enrichment (among significant)\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\ntop10_enriched = significant.nlargest(10, \"binom_fold_enrichment\")\n</code></pre>"},{"location":"guide/results/#terms-with-specific-genes","title":"Terms with Specific Genes","text":"<pre><code># Find terms containing a specific gene\ngene = \"TP53\"\nterms_with_gene = go_bp[go_bp[\"genes\"].str.contains(gene, na=False)]\n</code></pre>"},{"location":"guide/results/#summary-statistics","title":"Summary Statistics","text":"<pre><code># Count significant terms per ontology\nfor ontology, df in results.items():\n    n_significant = (df[\"binom_fdr\"] &lt; 0.05).sum()\n    print(f\"{ontology}: {n_significant} significant terms\")\n</code></pre>"},{"location":"guide/results/#compare-test-statistics","title":"Compare Test Statistics","text":"<pre><code># Compare binomial and hypergeometric tests\ngo_bp = results[\"GO Biological Process\"]\n\n# Terms significant in both tests\nboth_sig = go_bp[\n    (go_bp[\"binom_fdr\"] &lt; 0.05) &amp;\n    (go_bp[\"hyper_fdr\"] &lt; 0.05)\n]\n\n# Correlation between test statistics\ncorrelation = go_bp[\"binom_fdr\"].corr(go_bp[\"hyper_fdr\"])\n</code></pre>"},{"location":"guide/submitting-jobs/","title":"Submitting Jobs","text":"<p>This guide covers all the ways to submit genomic regions to GREAT using pygreat.</p>"},{"location":"guide/submitting-jobs/#input-formats","title":"Input Formats","text":"<p>pygreat accepts genomic regions in several formats:</p>"},{"location":"guide/submitting-jobs/#local-bed-file","title":"Local BED File","text":"<pre><code>from pygreat import GreatClient\n\nclient = GreatClient()\n\n# String path\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Path object\nfrom pathlib import Path\njob = client.submit_job(Path(\"peaks.bed\"), species=\"hg38\")\n</code></pre>"},{"location":"guide/submitting-jobs/#url-to-public-bed-file","title":"URL to Public BED File","text":"<p>If your BED file is publicly accessible, pass the URL directly. This skips the file upload step:</p> <pre><code>job = client.submit_job(\n    \"https://example.com/data/peaks.bed\",\n    species=\"hg38\",\n)\n</code></pre> <p>URL Support</p> <p>Using URLs is faster since pygreat doesn't need to upload your file to a hosting service first.</p>"},{"location":"guide/submitting-jobs/#pandas-dataframe","title":"pandas DataFrame","text":"<pre><code>import pandas as pd\n\nregions = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr1\", \"chr2\"],\n    \"start\": [1000, 5000, 10000],\n    \"end\": [2000, 6000, 11000],\n})\n\njob = client.submit_job(regions, species=\"hg38\")\n</code></pre> <p>The DataFrame must have columns for chromosome, start, and end positions. pygreat recognizes common column names:</p> <ul> <li>Chromosome: <code>chrom</code>, <code>chr</code>, <code>chromosome</code>, <code>seqnames</code></li> <li>Start: <code>start</code>, <code>chromStart</code>, <code>txStart</code></li> <li>End: <code>end</code>, <code>chromEnd</code>, <code>txEnd</code></li> </ul>"},{"location":"guide/submitting-jobs/#genomicregions-object","title":"GenomicRegions Object","text":"<p>For more control, use the <code>GenomicRegions</code> class directly:</p> <pre><code>from pygreat.models import GenomicRegions\n\nregions = GenomicRegions.from_bed(\"peaks.bed\")\njob = client.submit_job(regions, species=\"hg38\")\n</code></pre>"},{"location":"guide/submitting-jobs/#supported-species","title":"Supported Species","text":"<p>GREAT v4.0.4 supports these genome assemblies:</p> Species Assembly Description Human <code>hg38</code> GRCh38 (latest) Human <code>hg19</code> GRCh37 Mouse <code>mm10</code> GRCm38 Mouse <code>mm9</code> NCBI37 <pre><code># Human (GRCh38)\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\n\n# Mouse\njob = client.submit_job(\"peaks.bed\", species=\"mm10\")\n</code></pre>"},{"location":"guide/submitting-jobs/#association-rules","title":"Association Rules","text":"<p>GREAT uses association rules to link genomic regions to genes. Three rules are available:</p>"},{"location":"guide/submitting-jobs/#basal-plus-extension-default","title":"Basal Plus Extension (Default)","text":"<p>The <code>basalPlusExt</code> rule defines: - Basal domain: 5kb upstream, 1kb downstream of TSS - Extension: Up to 1Mb in both directions until another gene's basal domain</p> <pre><code>job = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    rule=\"basalPlusExt\",  # Default\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#two-closest-genes","title":"Two Closest Genes","text":"<p>The <code>twoClosest</code> rule extends each region to the two nearest genes' TSS (up to 1Mb):</p> <pre><code>job = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    rule=\"twoClosest\",\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#one-closest-gene","title":"One Closest Gene","text":"<p>The <code>oneClosest</code> rule extends each region to the single nearest gene's TSS:</p> <pre><code>job = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    rule=\"oneClosest\",\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#background-regions","title":"Background Regions","text":"<p>By default, GREAT uses the whole genome as background. For foreground/background analysis, provide background regions:</p> <pre><code>job = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    background=\"background.bed\",  # Background regions\n)\n</code></pre> <p>Background can also be a URL or DataFrame:</p> <pre><code># URL\njob = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    background=\"https://example.com/background.bed\",\n)\n\n# DataFrame\nbg_df = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr2\", \"chr3\"],\n    \"start\": [0, 0, 0],\n    \"end\": [10000000, 10000000, 10000000],\n})\njob = client.submit_job(regions_df, species=\"hg38\", background=bg_df)\n</code></pre>"},{"location":"guide/submitting-jobs/#coordinate-systems","title":"Coordinate Systems","text":"<p>BED files use 0-based, half-open coordinates by default. If your input uses 1-based coordinates, set <code>zero_based=False</code>:</p> <pre><code># 0-based coordinates (BED standard)\njob = client.submit_job(\"peaks.bed\", species=\"hg38\", zero_based=True)\n\n# 1-based coordinates (e.g., from GFF)\njob = client.submit_job(\"peaks.txt\", species=\"hg38\", zero_based=False)\n</code></pre>"},{"location":"guide/submitting-jobs/#job-naming","title":"Job Naming","text":"<p>Optionally provide a job name for identification:</p> <pre><code>job = client.submit_job(\n    \"peaks.bed\",\n    species=\"hg38\",\n    job_name=\"ChIP-seq_H3K4me3_sample1\",\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#client-configuration","title":"Client Configuration","text":"<p>Configure the client for different scenarios:</p> <pre><code>client = GreatClient(\n    version=\"4.0.4\",         # GREAT version\n    request_interval=30.0,   # Seconds between retries\n    max_retries=5,           # Max retry attempts\n    timeout=300.0,           # Request timeout (seconds)\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#rate-limiting","title":"Rate Limiting","text":"<p>GREAT limits concurrent requests. pygreat handles this with exponential backoff:</p> <pre><code># More patient retry settings\nclient = GreatClient(\n    request_interval=60.0,  # Wait 60s between retries\n    max_retries=10,         # Try up to 10 times\n)\n</code></pre>"},{"location":"guide/submitting-jobs/#error-handling","title":"Error Handling","text":"<p>Handle common errors:</p> <pre><code>from pygreat import GreatClient\nfrom pygreat.core.exceptions import (\n    InvalidSpeciesError,\n    RateLimitError,\n    GreatError,\n)\n\ntry:\n    client = GreatClient()\n    job = client.submit_job(\"peaks.bed\", species=\"hg38\")\nexcept InvalidSpeciesError as e:\n    print(f\"Invalid species: {e}\")\nexcept RateLimitError as e:\n    print(f\"Rate limited, try again later: {e}\")\nexcept GreatError as e:\n    print(f\"GREAT error: {e}\")\n</code></pre>"},{"location":"guide/visualization/","title":"Visualization","text":"<p>pygreat provides publication-ready visualizations for enrichment results using seaborn and matplotlib, as well as interactive HTML reports.</p>"},{"location":"guide/visualization/#interactive-html-reports","title":"Interactive HTML Reports","text":"<p>Generate a self-contained interactive HTML report from your enrichment results. The report includes everything you need to explore and present your results without writing any code.</p>"},{"location":"guide/visualization/#features","title":"Features","text":"<ul> <li>Summary Panel - Overview of total terms and significant terms per ontology</li> <li>Interactive Tables - Search, sort, and paginate through results with DataTables</li> <li>Global Filters - Filter by FDR threshold, p-value, category, and top N terms</li> <li>Term Details - Click any term to see full statistics, gene list, and links to AmiGO/QuickGO</li> <li>Plot Builder - Create bar or dot plots from selected terms directly in the browser</li> <li>Export - Download plots as SVG/PNG and data as TSV/CSV</li> </ul>"},{"location":"guide/visualization/#cli-usage","title":"CLI Usage","text":"<pre><code># Generate HTML report from enrichment results\npygreat report results.tsv -o report.html\n\n# Custom title\npygreat report results.tsv -o report.html -t \"ChIP-seq Enrichment Analysis\"\n\n# Stricter default FDR threshold\npygreat report results.tsv -o report.html --fdr-threshold 0.01\n</code></pre>"},{"location":"guide/visualization/#python-usage","title":"Python Usage","text":"<pre><code>from pygreat.report import ReportGenerator, ReportConfig\n\n# Basic usage\ngenerator = ReportGenerator()\ngenerator.generate(\"results.tsv\", \"report.html\")\n\n# With custom configuration\nconfig = ReportConfig(\n    title=\"My Enrichment Analysis\",\n    default_fdr=0.01,\n    default_top_n=50,\n)\ngenerator = ReportGenerator(config)\ngenerator.generate(\"results.tsv\", \"report.html\")\n\n# Generate from DataFrame\nimport pandas as pd\ndf = pd.read_csv(\"results.tsv\", sep=\"\\t\")\ngenerator.generate(df, \"report.html\")\n</code></pre>"},{"location":"guide/visualization/#report-walkthrough","title":"Report Walkthrough","text":"<ol> <li>Summary Cards - At the top, see total terms and significant terms (FDR &lt; 0.05) for each ontology category</li> <li>Filter Bar - Use the search box, FDR/p-value dropdowns, and Top N selector to focus on terms of interest</li> <li>Ontology Accordion - Click to expand/collapse each ontology section (Biological Process, Molecular Function, etc.)</li> <li>Data Tables - Each table is sortable and searchable; click column headers to sort</li> <li>Row Selection - Check boxes to select terms for plotting</li> <li>Term Modal - Click a term name to see detailed statistics and copy the gene list</li> <li>Plot Builder - Select terms, choose plot type (bar/dot), customize settings, and generate interactive Plotly plots</li> <li>Export - Download your customized plots or filtered data</li> </ol>"},{"location":"guide/visualization/#bar-plot","title":"Bar Plot","text":"<p>The bar plot shows the top enriched terms with -log10(FDR) values:</p> <pre><code>from pygreat import GreatClient\nfrom pygreat.viz import plot_enrichment_bar\n\n# Get results\nclient = GreatClient()\njob = client.submit_job(\"peaks.bed\", species=\"hg38\")\nresults = job.get_enrichment_tables()\n\n# Get significant GO terms\ngo_bp = results[\"GO Biological Process\"]\nsignificant = go_bp[go_bp[\"binom_fdr\"] &lt; 0.05]\n\n# Create bar plot\nfig, ax = plot_enrichment_bar(significant, n_terms=15)\nfig.savefig(\"barplot.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"guide/visualization/#customization-options","title":"Customization Options","text":"<pre><code>fig, ax = plot_enrichment_bar(\n    df,\n    n_terms=20,                    # Number of terms to show\n    pvalue_col=\"binom_fdr\",        # Column for significance\n    name_col=\"term_name\",          # Column for term names\n    title=\"GO Biological Process\", # Plot title\n    xlabel=\"-log10(FDR)\",          # X-axis label\n    color=\"steelblue\",             # Bar color\n    figsize=(10, 8),               # Figure size\n    max_label_length=50,           # Truncate long labels\n)\n</code></pre>"},{"location":"guide/visualization/#color-by-enrichment","title":"Color by Enrichment","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, ax = plot_enrichment_bar(\n    significant,\n    n_terms=15,\n    color=significant[\"binom_fold_enrichment\"],  # Color by fold enrichment\n)\nplt.colorbar(ax.collections[0], label=\"Fold Enrichment\")\n</code></pre>"},{"location":"guide/visualization/#dot-plot","title":"Dot Plot","text":"<p>The dot plot shows significance (x-axis), gene count (dot size), and fold enrichment (color):</p> <pre><code>from pygreat.viz import plot_enrichment_dot\n\nfig, ax = plot_enrichment_dot(significant, n_terms=15)\nfig.savefig(\"dotplot.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"guide/visualization/#customization-options_1","title":"Customization Options","text":"<pre><code>fig, ax = plot_enrichment_dot(\n    df,\n    n_terms=20,                     # Number of terms\n    pvalue_col=\"binom_fdr\",         # Significance column\n    size_col=\"observed_genes\",      # Column for dot size\n    color_col=\"binom_fold_enrichment\",  # Column for color\n    name_col=\"term_name\",           # Term name column\n    title=\"GO Enrichment\",          # Plot title\n    xlabel=\"-log10(FDR)\",           # X-axis label\n    figsize=(10, 8),                # Figure size\n    cmap=\"viridis\",                 # Colormap\n    size_range=(50, 500),           # Min/max dot sizes\n    max_label_length=50,            # Truncate labels\n)\n</code></pre>"},{"location":"guide/visualization/#saving-figures","title":"Saving Figures","text":""},{"location":"guide/visualization/#different-formats","title":"Different Formats","text":"<pre><code># PNG (raster, good for web)\nfig.savefig(\"plot.png\", dpi=300, bbox_inches=\"tight\")\n\n# PDF (vector, good for publications)\nfig.savefig(\"plot.pdf\", bbox_inches=\"tight\")\n\n# SVG (vector, good for editing)\nfig.savefig(\"plot.svg\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"guide/visualization/#transparent-background","title":"Transparent Background","text":"<pre><code>fig.savefig(\"plot.png\", dpi=300, bbox_inches=\"tight\", transparent=True)\n</code></pre>"},{"location":"guide/visualization/#multiple-ontologies","title":"Multiple Ontologies","text":"<p>Create plots for multiple ontologies:</p> <pre><code>import matplotlib.pyplot as plt\nfrom pygreat.viz import plot_enrichment_bar\n\nontologies = [\"GO Biological Process\", \"GO Molecular Function\", \"GO Cellular Component\"]\n\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\nfor ax, ontology in zip(axes, ontologies):\n    df = results.get(ontology)\n    if df is not None and not df.empty:\n        significant = df[df[\"binom_fdr\"] &lt; 0.05]\n        if not significant.empty:\n            plot_enrichment_bar(significant, n_terms=10, ax=ax, title=ontology)\n\nplt.tight_layout()\nfig.savefig(\"all_ontologies.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"guide/visualization/#comparison-plot","title":"Comparison Plot","text":"<p>Compare enrichment across conditions:</p> <pre><code>import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Assume you have results from two conditions\n# condition1_results and condition2_results\n\n# Merge top terms\ntop_terms = set(\n    condition1[\"GO Biological Process\"].nsmallest(20, \"binom_fdr\")[\"term_name\"]\n) | set(\n    condition2[\"GO Biological Process\"].nsmallest(20, \"binom_fdr\")[\"term_name\"]\n)\n\n# Create comparison DataFrame\ncomparison = []\nfor term in top_terms:\n    for cond, results in [(\"Condition 1\", condition1), (\"Condition 2\", condition2)]:\n        df = results[\"GO Biological Process\"]\n        row = df[df[\"term_name\"] == term]\n        if not row.empty:\n            comparison.append({\n                \"term\": term,\n                \"condition\": cond,\n                \"neg_log_fdr\": -np.log10(row[\"binom_fdr\"].values[0]),\n            })\n\ncomp_df = pd.DataFrame(comparison)\n\n# Create grouped bar plot\nplt.figure(figsize=(12, 8))\nsns.barplot(data=comp_df, y=\"term\", x=\"neg_log_fdr\", hue=\"condition\")\nplt.xlabel(\"-log10(FDR)\")\nplt.ylabel(\"\")\nplt.title(\"GO Enrichment Comparison\")\nplt.tight_layout()\nplt.savefig(\"comparison.png\", dpi=300)\n</code></pre>"},{"location":"guide/visualization/#heatmap","title":"Heatmap","text":"<p>Create a heatmap of enrichment across multiple samples:</p> <pre><code>import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Collect -log10(FDR) for top terms across samples\nsamples = [\"Sample1\", \"Sample2\", \"Sample3\"]\ntop_terms = [\"apoptotic process\", \"cell cycle\", \"DNA repair\", ...]  # Your terms\n\n# Build matrix\nmatrix = np.zeros((len(top_terms), len(samples)))\nfor j, sample in enumerate(samples):\n    df = sample_results[sample][\"GO Biological Process\"]\n    for i, term in enumerate(top_terms):\n        row = df[df[\"term_name\"] == term]\n        if not row.empty:\n            matrix[i, j] = -np.log10(row[\"binom_fdr\"].values[0])\n\n# Create heatmap\nplt.figure(figsize=(8, 10))\nsns.heatmap(\n    matrix,\n    xticklabels=samples,\n    yticklabels=top_terms,\n    cmap=\"YlOrRd\",\n    cbar_kws={\"label\": \"-log10(FDR)\"},\n)\nplt.title(\"GO Enrichment Heatmap\")\nplt.tight_layout()\nplt.savefig(\"heatmap.png\", dpi=300)\n</code></pre>"},{"location":"guide/visualization/#cli-visualization","title":"CLI Visualization","text":"<p>Create plots from the command line:</p> <pre><code># Bar plot (default)\npygreat plot results.tsv -t \"GO Biological Process\" -o barplot.png\n\n# Dot plot\npygreat plot results.tsv -t \"GO Biological Process\" --plot-type dot -o dotplot.png\n\n# Customize number of terms\npygreat plot results.tsv -t \"GO Biological Process\" -n 20 -o barplot.png\n</code></pre>"},{"location":"guide/visualization/#styling-tips","title":"Styling Tips","text":""},{"location":"guide/visualization/#publication-quality","title":"Publication Quality","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Set publication style\nplt.style.use('seaborn-v0_8-whitegrid')\nplt.rcParams.update({\n    'font.size': 12,\n    'font.family': 'sans-serif',\n    'axes.labelsize': 14,\n    'axes.titlesize': 16,\n    'xtick.labelsize': 12,\n    'ytick.labelsize': 12,\n})\n\nfig, ax = plot_enrichment_bar(significant, n_terms=15)\nfig.savefig(\"publication_plot.pdf\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"guide/visualization/#dark-theme","title":"Dark Theme","text":"<pre><code>plt.style.use('dark_background')\nfig, ax = plot_enrichment_bar(significant, n_terms=15, color=\"lightblue\")\n</code></pre>"}]}